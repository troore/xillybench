--ffd0 0015103933880020001 Page 1 of MANIFEST
7bf681 1 MANIFEST
ec8ce7 2 readme.txt
05e777 3 autoconf.c
cedb16 4 build.bat
a0056e 5 chipio.c
151f75 6 chipio.h
1a8e30 7 des.c
11db2a 8 des.h
0aac3f 9 initsrch.c
0f78d8 10 keyblock.c
f699dd 11 keyblock.h
ba96cf 12 search.c
5127f6 13 search.h

--e562 0004451557280020002 Page 1 of readme.txt
e0af5a
1aaf5a
d44c86 иииииииииREADME FOR DES SEARCH ENGINE CONTROLLER SOFTWARE
afaf5a
29825e иииииииииииииииииииииииииApril 23, 1998
4aaf5a
0eaf5a
fb3fcf Written 1998 by Cryptography Research (http://www.cryptography.com)
216a64 for the Electronic Frontier Foundation (EFF). иPlaced in the public
4ad8d3 domain by Cryptography Research and EFF.
a7af5a
50ff62 This is unsupported free software. иUse and distribute at your own
e0daf4 risk. U.S. law may regulate the use and/or export of this program.
ffeaa2 Foreign laws may also apply.
f7af5a
b4af5a
34af5a
fa176f ---------------------------------------------------------------------
b1a6ff Section 1: иCompiling the Programs.
79af5a
801f81 Compiling the programs should be easy. иUsing 32-bit Microsoft Visual
a26186 C++ for Windows compile as shown below. иFor Borland C++ or other
1d3a41 compilers, replace "cl" with the compiler name (e.g., bcc). иOn a 16-
7c7812 bit DOS compiler with a large search array, the large memory model
3f769d (Borland's "-ml" flag) is required or the system will run out of
392d57 memory.
62af5a
ce209c иии> cl search.c keyblock.c chipio.c des.c
fcc3fb иии> cl initsrch.c keyblock.c
6b758b иии> cl autoconf.c chipio.c
7057a9 иии> cl testvec.c sim.c des.c
42af5a
b8af5a
1caf5a
ea176f ---------------------------------------------------------------------
93e4fb Section 2: иAuto-Configuring the Search Array.
80af5a
19d9c3 The auto-configuration program is an important part of the DES
292f7e Cracker. иBecause there are a large number of chips in the system, it
9fb6be is inevitable that a few fail. иBy automatically removing defective

0d0b4b units, it is not necessary to repair the system when failures do
4f9dc9 occur.
a8af5a
018826 The program "autoconf.exe" will automatically identify the
6f723b configuration of a search array. иWith the I/O port base address at
cd7d24 210 hex, simply run the program with the command:
5daf5a
75065b иии> autoconf search.cfg -t
98af5a
c7e245 Note that the "-t" flag performs register testing (recommended if the
dfdfea search system might contain defective chips that need to be avoided).
e003e2 If the I/O port is at an address other than 210, specify the address.
ff49ba The "-v" flag provides verbose output. иFor example:
c1af5a
2faf9f иии> autoconf search.cfg 210 -t -v
26af5a
185f44 When autoconf completes, it will print the total number of chips to
bae103 the screen and save the configuration information to the
f44721 configuration file. иThe configuration can be edited (e.g., with
942a9c grep) to remove defective units not caught with autoconf.
8daf5a
70e81e (Note that this first release does not implement search unit testingи
7f1a7b code except for the register tests.)и
74af5a
d9af5a
47af5a
cd176f ---------------------------------------------------------------------
2611d1 Section 3: иInitializing a Search.
40af5a
7c71c4 The search parameters have to be specified before a key can be found.
0b480d The program initsrch creates a "search context" file that contains
443422 these search parameters and a list of the regions of keyspace that

--8d6f 0009a4c5f7080020002 Page 2 of readme.txt
6d2d23 remain to be searched.
f3af5a
757db9 The search parameters can either be entered into initsrch or
03be37 specified on the command line. иTo enter them manually, run initsrch
b17249 with no parameters:
34af5a
f0a5ad иии> initsrch
d4af5a
83b591 The program will then prompt for the search context file. иPress
a473ca enter for the default filename ("search.ctx").
98af5a
953b91 Next, the program will prompt for a search mode. иFive modes areи
096098 supported and are described in the following sections.и
30af5a
45b5a1 иииK - Known plaintext
442856 иииE - ECB ASCII text
019879 иииC - CBC ASCII text
31e1fd иииB - Blaze challenge
ddbb69 иииM - Manual parameter specification
e9af5a
5eaf5a
2edf4c 1. иKnown plaintext searching
ccaf5a
06f1ec This is the simplest (and most common) mode of operation. иIf a
4dd2c9 complete DES plaintext/ciphertext pair is known, this mode can be
0f91b5 used to quickly search for the key. иWhen prompted, enter the
c281eb plaintext in hexadecimal form (e.g., "123456789ABCDEF0") and press
95792f enter. иNext, enter the ciphertext, also in hexadecimal. The program
6fb05a will then create a search context file and exit.
d1af5a
fcaf5a
68cc8f 2. иECB ASCII text searching
9aaf5a
6e7074 If your target message is known to be ASCII text and was encrypted
1edff6 using DES ECB mode, enter two different ciphertexts. иThe program
d92df0 will create the search context file and exit. иThe program is
234bf0 configured to include all letters ("a-z" and "A-Z"), numbers ("0-9"),
470b54 and common punctuation (ASCII zero, tab, linefeed carriage return,
0ded96 space, and common punctuation (!"'(),-.^_). иFor other character
98fbc6 sets, use the manual parameter specification option.
f8af5a
bcaf5a
a7fe29 3. иCBC ASCII text searching
caaf5a
f85465 If your message is ASCII text and was encrypted using DES CBC mode,
bae166 this option lets you specify an initialization vector and two
aa45de ciphertext messages. иThe CBC mode ASCII option uses the same ASCII
6c4548 text characters as ECB ASCII.
09af5a
18af5a
706ad7 4. иThe Blaze challenge
0caf5a
20b2e8 Matt Blaze's DES challenge involves searching for a key such that a
4f29b1 repeated plaintext byte produces a repeated ciphertext byte. иThis
98ce02 option will search for keys that meet the challenge. Simply specify
2851f0 the desired repeated ciphertext byte.
68af5a
6baf5a
fba0ab 5. иManual parameter specification
e2af5a
f4f30d The manual parameter mode allows direct control over the search
a1c03a parameters. The manual mode requires entering more data than the
f21978 other modes; it is often easier to pipe input from a script file,
3cab72 e.g.:
6caf5a
114c2d иии> initsrch < search.scr
5baf5a
b6c924 First, enter the plaintext vector. иThis is 64 hex digits long and
984fe4 specifies the bytes that can appear in "valid" plaintexts. The most
caf7a9 significant bit of the left-hand digit specifies whether ASCII 255
ea0906 can appear, and the least significant bit of the last digit specifies
9ad545 whether ASCII zero can appear. For example, the plaintext vector for

--0018 00065d8074680020002 Page 3 of readme.txt
569be0 the ASCII text modes is:
45af5a
328424 иии0000000000000000000000000000000007FFFFFFC7FFFFFE8FFF738700002601
47af5a
6294a7 Next, enter the initialization vector for the first DES, if any.
6b8f16 This will be XORed onto the first plaintext before its validity is
5587b3 checked.
b6af5a
f4fd67 Next, enter the two ciphertexts (ciphertext 0 and ciphertext 1).
aaf9a7 These may be the same or different.
a2af5a
d4a2dd Next, enter the plaintext byte mask. иThis sets bits that should be
f36fe4 ignored in the plaintext. иFor example, if the left-hand byte of the
cac85d plaintext is unknown or can have any value, the plaintext byte mask
379f87 would be set to 80 (hex).
11af5a
9d87cc Finally, enter the searchInfo byte. Bit 1 of this byte specifies
97a928 whether CBC mode should be used. иIf so, the first ciphertext will be
595ef9 XORed onto candidate plaintexts produced by decrypting the second
2dff09 ciphertext. иBit 2 of searchInfo specifies whether the extraXor
13de86 operation should be done. This operation XORs the right half of the
8aac2c plaintext onto the left half before it is checked. и(For the Blaze
06de4f challenge, the desired plaintext has a single byte repeated. иThe
13ab4a extraXor operation will set the left half of the plaintext to zero if
c6781e the plaintext is good. иThe plaintextByteMask can then be set to 0x0F
e2b3f0 to ignore the right half and the plaintextVector has only the bit for
521d7e ASCII zero set.)
39af5a
1baf5a
4c288d 5. иThe search context file
8daf5a
179dcb The search context file contains a header, the search parameters, and
8f1477 2^24 bits corresponding to the unsearched key regions. иThe search
91edfe parameters are: plaintextVector (32 bytes), plaintextXorMask (8
55d722 bytes), ciphertext0 (8 bytes), ciphertext1 (8 bytes),
3583fb plaintextByteMask (1 byte), and searchInfo (1 byte). иEach search
421808 region includes 2^32 keys. The first bit (the MSB of the first key
c79bf0 region byte) corresponds to the keys 00000000000000 through
462847 000000FFFFFFFF, in 56-bit notation. и(To produce the 56-bit form of a
f21751 64-bit DES key, delete the eight parity bits.)
d6af5a
efaf5a
f5af5a
48176f ---------------------------------------------------------------------
81999d Section 4: иRunning a Search.
c1af5a
05ae2f The most common way to run a search is to type:
5caf5a
057f42 иии> search search.cfg search.ctx logfile -q
2faf5a
80edd9 The "-q" flag requests quiet output, which prints less information to
e101f1 the screen. иThe search.cfg file is produced by autoconf, and
2200bc search.ctx is produced by initsrch. иThe logfile will contain a list
f4a0ec of candidate keys encountered.
12af5a
223e71 If a search is stopped partway through, work done in partially-
0c0b95 completed key regions is lost, but completed regions are noted in the
a252e6 search context file. иNote that a complete search will produce a
433e44 rather large amount of data in the logfile. иIf hard disk space is
649464 limited, it may be desirable to stop the search occasionally (for
9ad667 example, daily) to purge the logfile.
c2af5a
5daf5a
1eaf5a
8b176f ---------------------------------------------------------------------
f98443 Section 5: иPorting to other platforms.
d9af5a
9aa861 When porting to other platforms, some code changes or additions may
9a17dd be required. иThe following may not be found on all systems:
49af5a
0946df ииииииstricmp: иииThis is a case-insensitive strcmp found on many
659051 ииииииииииcompilers. иIf it isn't present, you can either use strcmp

--a334 0019f8825ad80020002 Page 4 of readme.txt
70faf5 ииииииииии(though commands will become case sensitive) or write one.
4daf5a
57970a ииииииSEEK_SET: ииA constant (equal to zero) used to tell fseek()
bdc708 ииииииииииto go to a fixed offset. иUsually defined in stdio.h
02af5a
ca5e28 ииииииkbhit(void): иReturns true if a key has been pressed. (Used to
662151 ииииииииииcheck for commands during searches.)
bbaf5a
6d2832 ииииииgetch(void): иReads a keystroke from the keyboard.
4daf5a
c13802 ииииииinportb(unsigned portNum): иReads a byte from an I/O port. Used
5c2f71 ииииииииииonly by chipio.c. иOn other platforms, inportb may need to
27977e ииииииииииbe emulated. и(For Visual C++, inportb is implemented in
3c461d ииииииииииchipio.c as inline assembly language.)
97af5a
9e58f5 ииииииoutportb(int portNum, int value): иSends a byte to an I/O port.
59dbb1 ииииииииииUsed only by chipio.c. иOn other platforms, outportb may
3bb05f ииииииииииneed to be emulated. и(For Visual C++, outportb is
0f88ab ииииииииииimplemented in chipio.c as inline assembly language.)
a3af5a
1eaf5a
bbaf5a
f7176f ---------------------------------------------------------------------
a166bf Section 6: иFinal comments
15af5a
05182b As this code goes to press, there was little opportunity for testing
a3aa2b and the code has not undergone any of the assurance, code review, or
a4419d testing processes we normally use. иWhen working on the code, you
57167e you may find a few bugs. иFeedback, as always, is appreciated.
9baf5a
dba0c7 Paul Kocher, Josh Jaffe, and everyone else at Cryptography Research
969732 would like to thank John Gilmore and the EFF for funding this unique
1930dc project, and AWT for their expert hardware work!
37af5a
9faf5a

--8884 0008b9a267780020003 Page 1 of autoconf.c
8d2d03 /*****************************************************************************
caf463 и* autoconf.c иииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииии*
4740b6 и* ииииииииииииииииииииSearch Engine Controller Program иииииииииииииииииииии*
c429eb и* ииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииии*
6c09fc и* иииWritten 1998 by Cryptography Research (http://www.cryptography.com) иии*
938aaf и* ииииииand Paul Kocher for the Electronic Frontier Foundation (EFF). ииииии*
b9caeb и* ииииииPlaced in the public domain by Cryptography Research and EFF. ииииии*
184992 и* иTHIS IS UNSUPPORTED FREE SOFTWARE. USE AND DISTRIBUTE AT YOUR OWN RISK. и*
2129eb и* ииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииии*
6cc755 и* иIMPORTANT: U.S. LAW MAY REGULATE THE USE AND/OR EXPORT OF THIS PROGRAM. и*
5529eb и* ииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииии*
03489b и*****************************************************************************
5129eb и* ииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииии*
3215cb и* ииIMPLEMENTATION NOTES: ииииииииииииииииииииииииииииииииииииииииииииииииии*
f829eb и* ииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииии*
dfa8b8 и* ииThis program automatically determines the configuration of a search ииии*
491db9 и* ииarray. иAdditional diagnostic code should be added to detect common ииии*
2e87f9 и* ииchip failures (once these are known). ииииииииииииииииииииииииииииииииии*
fe29eb и* ииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииии*
26489b и*****************************************************************************
3b29eb и* ииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииии*
286eef и* ииREVISION HISTORY: ииииииииииииииииииииииииииииииииииииииииииииииииииииии*
5429eb и* ииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииии*
4528d9 и* ииVersion 1.0: иInitial release by Cryptography Research to EFF. иииииииии*
3b486f и* ииииииииииииииииNote: Detailed diagnostic tests not implemented yet. иииии*
c829eb и* ииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииии*
34d8c3 и*****************************************************************************/
29af5a
05bcd3 #define SOFTWARE_VERSION "1.0"
9aa5c9 #define SOFTWARE_DATE иии"04-21-1998"
86af5a
d7af5a
d4bea3 #include <stdlib.h>
a4feb2 #include <stdio.h>
ddbb5f #include <assert.h>
e5c737 #include <memory.h>
ed0a8b #include <time.h>
f8b1cb #include <ctype.h>
d91519 #include "chipio.h"
7baf5a
822d85 #define MAX_CHIPS_PER_BOARD и64
e191af #define MAX_BOARDS ииииииииии256
59af5a
9e708e static void EXIT_ERR(char *s) { fprintf(stderr, s); exit(1); }
619101 void AutoconfigureScan(FILE *fp, int fullScan, int verbose);
c0e5e4 int QuickCheckRegister(int board, int chip, int register, int value);
cd6c9b void AddSearchUnits(FILE *fp, int board, int chip, int unit, int isGood);
6693c5 long DoFullScan(FILE *fp, int board, int* chips, int verbose);
a7af5a
fcaf5a
ac164b int main(int argc, char **argv) {
413850 ииint testLoops = -1;
1087d8 ииint baseIoPort = 0x210;
2dadb6 ииint i, nextArg, fullScan;
792659 ииint verbose = 0;
51bc33 ииchar buffer[200];
4779c7 ииchar *fileSpec;
58b166 ииFILE *fp;
9ec1cd ииchar *helpMsg = "Usage: autoconf search.cfg [baseIoPort] [-v] [-t#]\n\n"
c24b8d ииииииииииииииии" иииииииии-v: иVerbose operation\n"
deec61 ииииииииииииииии" иsearch.cfg: иThe output file for the config info.\n"
eccff8 ииииииииииииииии" иbaseIoPort: иHex base port of I/O card (default=210 hex)\n"
aa6d8e ииииииииииииииии" ииииииии-t#: иExtra testing (see below)\n"
be1228 ииииииииииииииии"\nUse the -t# to do more than a quick test for chips.\n"
25a0c7 ииииииииииииииии" ииииииии-t0: иDo full read/write test of chip registers\n"
4e10f3 ииииииииииииииии" ииииииии-t#: иDo # iterations of a full system test\n";
16af5a
b0ddd7 ииprintf("\nDES Search Engine Configurer (Ver %s, %s). May be export "
84ffaa иииииииии"controlled.\nWritten 1998 by Cryptography Research "
bc2e08 иииииииии"(http://www.cryptography.com) for EFF.\n"
75c4fd иииииииии"This is unsupported "
8b1151 иииииииии"free software: Use and distribute at your own risk.\n"

--bbb9 0003461923980020003 Page 2 of autoconf.c
d1805d иииииииии"-------------------------------------------"
ef04bf иииииииии"---------------------------------\n\n\n",
5aa1fb иииииииииSOFTWARE_VERSION, SOFTWARE_DATE);
6daf5a
aebc9a ииif (argc < 2 || argv[1][0] == '-')
a78298 ииииEXIT_ERR(helpMsg);
03e776 ииfileSpec = argv[1];
ba353d ииfor (nextArg = 2; nextArg < argc; nextArg++) {
7715da ииииif (argv[nextArg][0] == '-' || argv[nextArg][0] == '/') {
83cfff ииииииif (toupper(argv[nextArg][1]) == 'T') {
1f2647 ииииииииsscanf(argv[nextArg]+2, "%d", &testLoops);
fbac1e ииииииииif (testLoops < 0)
dc4adf ииииииииииtestLoops = 0;
4cb396 ииииии} else if (toupper(argv[nextArg][1]) == 'V')
1e568e ииииииииverbose = 1;
7d3dfa ииииииelse
e18d34 ииииииииEXIT_ERR("Bad parameter (run with no parameters for help)\n");
6d6a79 ииии} else {
a869b6 ииииииsscanf(argv[nextArg], "%x", &baseIoPort);
7c26c3 ииииииif (baseIoPort <= 0)
1e8d34 ииииииииEXIT_ERR("Bad parameter (run with no parameters for help)\n");
b76fe7 ииии}
31df1c ии}
41af5a
aa398a ииif (verbose) printf("Test parameters:\n");
190e23 ииif (verbose) printf(" ииBaseIOPort = %x\n", baseIoPort);
7ae35c ииif (verbose) printf(" ииoutfile = \"%s\"\n", fileSpec);
d9d292 ииif (verbose) if (testLoops < 0) printf(" ииQuick scan only\n");
b06835 ииif (verbose) if (testLoops== 0) printf(" ииFull register scan\n");
b9142f ииif (verbose) if (testLoops > 0) printf(" ии%d DES tests\n", testLoops);
d9af5a
64078e ииfp = fopen(fileSpec, "w");
d9b291 ииif (fp == NULL)
a8eee0 ииииEXIT_ERR("Error opening output file.\n");
7a575c ииfprintf(fp, "%% Auto-generated search system config file\n");
98932f ииfprintf(fp, "PORT=%x\n", baseIoPort);
baaf5a
253c81 ииSetBaseAddress(baseIoPort);
d96af7 ииfullScan = (testLoops < 0) ? 0 : 1;
91bad4 ииAutoconfigureScan(fp, fullScan, verbose);
aced24 ииfclose(fp);
faaf5a
368f0d ииfor (i = 0; i < testLoops; i++) {
b2c130 ииииprintf("Doing DES test %d of %d.\n", i+1, testLoops);
62bb1a ииииfp = fopen(fileSpec, "w+");
a541c7 ииииif (fp == NULL)
00495c ииииииEXIT_ERR("Error reopening output file.\n");
864529 ииииfgets(buffer, 190, fp); иииииииииииииииииииииииииииии/* skip header line */
ef7769 ииииfgets(buffer, 190, fp); иииииииииииииииииииииииииииииии/* skip port line */
5d2f5d ииииfprintf(stderr, "*** Detailed test not implemented !!!\n");
b0b174 ииииfclose(fp);
65df1c ии}
91c86a ииreturn (0);
57efe6 }
bdaf5a
e4af5a
8daf5a
e238e5 /*
65e484 и* иAutomatically figure out the configuration of the search system.
d66bac и* иThus function assumes that SetBaseAddress() has already been called.
dd495d и*/
84fb6d void AutoconfigureScan(FILE *fp, int fullScan, int verbose) {
6e4007 ииint board, chip, chipCount, value;
67b920 ииlong totalChips = 0;
65021b ииint chips[MAX_CHIPS_PER_BOARD];
2baf5a
dca3b4 ииif (verbose) printf("**** DOING AUTOCONFIGURE SCAN ****\n");
f9378a ииfor (board = 0; board < MAX_BOARDS; board++) {
08dfb2 ииииprintf("CHECKING BOARD 0x%02X: ", board);
06442d ииииfflush(stdout);
3680db ииииchipCount = 0;
34211c ииииfor (chip = 0; chip < MAX_CHIPS_PER_BOARD; chip++) {

--1d3d 0008613f79280020003 Page 3 of autoconf.c
1e563d ииииии/* TEST FIRST BYTE OF CIPHERTEXT 0 (REGISTER 0x28) */
79c8a7 ииииииvalue = rand() & 0xFF;
527510 ииииииif (QuickCheckRegister(board, chip, 0x28, value) == 0 ||
5acc0c ииииииииииQuickCheckRegister(board, chip, 0x28, value^255) == 0) {
78875d ииииииииchips[chip] = 0;
8c328b ииииииииif (verbose) printf("\n ииBOARD 0x%02X CHIP 0x%02X: Not found.",
e9d006 ииииииииииииииииboard, chip);
b0cfc7 ииииии} else {
41dd81 ииииииииchips[chip] = 1;
dad3c2 ииииииииchipCount++;
f287c8 ииииииииif (verbose) printf("\n ииBOARD 0x%02X CHIP 0x%02X: FOUND",board,chip);
903982 ииииииииif (fullScan) {
b2986b ииииииииииif (verbose) printf("\n ииCHIP 0x%02X: Halting chip for test", chip);
61fde4 ииииииииииSetRegister(board, chip, REG_PTXT_BYTE_MASK, 0xFF);
d17fb0 ииииииии}
8842cc ииииии}
e96fe7 ииии}
47f418 ииииif (verbose) printf("\n");
347082 ииииprintf(" иFound %4d chips total.\n", chipCount);
90af5a
fdcb4a ииии/* DO DETAILED REGISTER SCAN IF REQUESTED */
e9eef1 ииииif (fullScan && chipCount) {
45f0b8 ииииииtotalChips = DoFullScan(fp, board, chips, verbose);
e46a79 ииии} else {
0db79b ииииииchipCount = 0;
e2f9e5 ииииииfor (chip = 0; chip < MAX_CHIPS_PER_BOARD; chip++) {
77b833 ииииииииif (chips[chip]) {

b0d098 ииииииииииchipCount++;
2b3758 ииииииииииtotalChips++;
065ead ииииииииииAddSearchUnits(fp, board, chip, -1, 1);
237fb0 ииииииии}
cd42cc ииииии}
516fe7 ииии}
f5df1c ии}
21397d ииif (verbose) printf("*** AUTOCONFIGURE SCAN COMPLETE ***\n");
05c77d ииprintf("Found %ld chips total.\n", totalChips);
daefe6 }
f1af5a
c3af5a
66ddaa int QuickCheckRegister(int board, int chip, int reg, int value) {
ff8085 ииSetRegister(board, chip, reg, value);
953c2d ииif (GetRegister(board, chip, reg) != value)
25943a ииииreturn (0);
30d4d1 ииreturn (1);
ffefe6 }
a1af5a
dcaf5a
8cc043 void AddSearchUnits(FILE *fp, int board, int chip, int unit, int isGood) {
5717e0 ииint i;
98af5a
e9b306 ииif (unit < 0) {
e154b0 ииииfor (i = 0; i < SEARCH_UNITS_PER_CHIP; i++)
265e78 ииииииAddSearchUnits(fp, board, chip, i, 1);
3349d8 ии} else {
1fac09 ииииfprintf(fp, "%s=0x%02X 0x%02X 0x%02X\n", isGood ? "UNIT" : "FAIL",
11229d ииииииииииииboard, chip, unit);
5adf1c ии}
98efe6 }
feaf5a
0eaf5a
777b47 long DoFullScan(FILE *fp, int board, int* chips, int verbose) {
8eff49 ииint chip, reg, seed, value, i, j;
33160d ииint units[24];
0fb920 ииlong totalChips = 0;
ccaf5a
24d7a0 ииif (verbose) printf(" ии--- Register scan on board 0x%02X ---\n", board);
deaf5a
623f7a ии/* PICK A SEED & USE IT TWICE (ONCE WHEN SETTING & ONCE WHEN CHECKING */
a172a5 ииseed = (int)time(NULL);
f4af5a
bb775e ии/*** SET REGISTERS ***/
86db8d ииsrand(seed);

--ff7e 00105deab4880020003 Page 4 of autoconf.c
bc3f58 ииfor (chip = 0; chip < MAX_CHIPS_PER_BOARD; chip++) {
d05448 ииииif (chips[chip] == 0)
325f6a ииииииcontinue;
8c9858 ииииif (verbose) printf(" ииBOARD 0x%02X CHIP 0x%02X: Setting regs.\n",
d05be4 ииииииииииииboard, chip);
eab177 ииииfor (reg = 0; reg <= 0xFF; reg++) {
e5beec ииииииif ((reg >= 0x39 && reg < 0x40) || (reg > 0x40 && (reg & 7) == 7))
7ca511 ииииииииииииcontinue;
cec87b ииииииииvalue = rand() & 255;
9aca50 ииииииииSetRegister(board, chip, reg, value);
7e6fe7 ииии}
e2df1c ии}
ebaf5a
60d84d ии/*** CHECK REGISTERS ***/
57db8d ииsrand(seed);
843f58 ииfor (chip = 0; chip < MAX_CHIPS_PER_BOARD; chip++) {
1a5448 ииииif (chips[chip] == 0)
7d5f6a ииииииcontinue;
d51775 ииииfor (i = 0; i < 24; i++)
d30734 ииииииunits[i] = 1;
d4a885 ииииif (verbose) printf(" ииBOARD 0x%02X CHIP 0x%02X: Checking...\n",
6c5be4 ииииииииииииboard, chip);
5ab177 ииииfor (reg = 0; reg <= 0xFF; reg++) {
00beec ииииииif ((reg >= 0x39 && reg < 0x40) || (reg > 0x40 && (reg & 7) == 7))
17a511 ииииииииииииcontinue;
205f9e ииииииvalue = rand() & 255;
2da5d1 ииииииi = GetRegister(board, chip, reg);
3acb31 ииииииSetRegister(board, chip, reg, value ^ 255);
39b29a ииииииj = GetRegister(board, chip, reg);
c71a0d ииииииif (i != value || j != (value ^ 255)) {
cb5495 ииииииииif (chips[chip])
b7125b ииииииииииprintf("\n *** BOARD 0x%02X, CHIP 0x%02X FAILED ***\n иDetails: ",
0ba711 ииииииииииииииииииboard, chip);
6d08d0 ииииииииif (reg < 0x40)
056181 ииииииииииchips[chip] = 0;
a31e5b ииииииииelse
d464e9 ииииииииииunits[(reg - 0x40)/8] = 0;
0e6b2c ииииииииif (i != value || j != value)
15f088 ииииииииииprintf("\n иBoard 0x%02X Chip 0x%02X Reg 0x%02X bad:",

dd88d1 ииииииииииииboard, chip, reg);
6e3a74 ииииииииif (i != value)
1e6ac7 ииииииииииprintf(" иGot 0x%02X, not %02X.", i, value);
c746af ииииииииif (j != (value ^ 255))
1547f8 ииииииииииprintf(" иGot 0x%02X, not %02X.", j, value ^ 255);
d8cfc7 ииииии} else {
8bef4b ииииииииif (verbose)
dfa942 ииииииииииprintf("\n ииReg 0x%02X good (Read 0x%02X)", reg, value);

8742cc ииииии}
676fe7 ииии}
b15448 ииииif (chips[chip] == 0)
e1b2b4 ииииииprintf("\n и-- CHIP FAILED --\n");
bf83c8 ииииelse {
2ca741 ииииииfor (i = 0; i < 24; i++)
2e958f ииииииииAddSearchUnits(fp, board, chip, i, units[i]);
3688b7 ииииииtotalChips++;
e46fe7 ииии}
ccdf1c ии}
c00cbb ииreturn (totalChips);
47efe6 }
deaf5a
05af5a

--4dcb 001b8acf45a80020004 Page 1 of build.bat
eb1685 rem Sample build script (using Microsoft Visual C++)
89af5a
a05793 cl search.c keyblock.c chipio.c des.c
049d12 cl initsrch.c keyblock.c
818947 cl autoconf.c chipio.c
110940 cl testvec.c sim.c des.c
b8af5a
--27e3 000793f2b7c80020005 Page 1 of chipio.c
8d2d03 /*****************************************************************************
a07c89 и* chipio.c иииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииии*
87350a и* ииииииииииииSearch Engine Low-Level Hardware Interface Module ииииииииииии*
be29eb и* ииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииии*
3309fc и* иииWritten 1998 by Cryptography Research (http://www.cryptography.com) иии*
b28aaf и* ииииииand Paul Kocher for the Electronic Frontier Foundation (EFF). ииииии*
aecaeb и* ииииииPlaced in the public domain by Cryptography Research and EFF. ииииии*
6c4992 и* иTHIS IS UNSUPPORTED FREE SOFTWARE. USE AND DISTRIBUTE AT YOUR OWN RISK. и*
6d29eb и* ииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииии*
95c755 и* иIMPORTANT: U.S. LAW MAY REGULATE THE USE AND/OR EXPORT OF THIS PROGRAM. и*
f329eb и* ииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииии*
12489b и*****************************************************************************
0e29eb и* ииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииии*
596eef и* ииREVISION HISTORY: ииииииииииииииииииииииииииииииииииииииииииииииииииииии*
6629eb и* ииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииии*
2f28d9 и* ииVersion 1.0: иInitial release by Cryptography Research to EFF. иииииииии*
d929eb и* ииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииии*
3dd8c3 и*****************************************************************************/
49af5a
c8feb2 #include <stdio.h>
ab1465 #include <conio.h>
efbea3 #include <stdlib.h>
4e1519 #include "chipio.h"
24af5a
fc411c static int CURRENT_BOARD ииии= -1;
0ce1ec static int CURRENT_CHIP иииии= -1;
b3ed93 static int CURRENT_PORT_CNFG = -1;
766981 static int IO_BASE_ADDRESS = 0x210;
29af5a
ec08d9 #define IO_PORTA_ADDRESS (IO_BASE_ADDRESS+0)
823310 #define IO_PORTB_ADDRESS (IO_BASE_ADDRESS+1)
40fc87 #define IO_PORTC_ADDRESS (IO_BASE_ADDRESS+2)
5f8cee #define IO_CNFG_ADDRESS и(IO_BASE_ADDRESS+3)
7d9f2f #define CNFG_OUTPUT ии0x80
b52497 #define CNFG_INPUT иии0x82
5aaf5a
3c4951 #define CTRL_BASE иииииии0x1B иииии/* base value onto which others are XORed */
663867 #define CTRL_RST ииииииии0x20
e7dec1 #define CTRL_RDB ииииииии0x10
8a8735 #define CTRL_WRB ииииииии0x08
777b8e #define CTRL_ALE ииииииии0x04
dd9757 #define CTRL_ADRSEL2 ииии0x02 ииииии/* in documentation is also called CNTR1 */
e884f1 #define CTRL_ADRSEL1 ииии0x01 ииииии/* in documentation is also called CNTR0 */
49af5a
8738e5 /*
4ce308 и* иDELAYS CAN BE ADDED TO DEAL WITH BUS LOADING/CAPACITANCE/ETC.
59495d и*/
aee62f #define DELAY_FACTOR 100L
67ac33 #define DELAY_ADDRESS_SETTLE ии0*DELAY_FACTOR
e5126b #define DELAY_DATA_SETTLE иииии0*DELAY_FACTOR
b62102 #define DELAY_RST_HOLD ииииииии0*DELAY_FACTOR
3a8807 #define DELAY_RST_RECOVER иииии0*DELAY_FACTOR
c48418 #define DELAY_RDB_HOLD ииииииии0*DELAY_FACTOR
c82d1d #define DELAY_RDB_RECOVER иииии0*DELAY_FACTOR
439bf5 #define DELAY_WRB_HOLD ииииииии0*DELAY_FACTOR
7532f0 #define DELAY_WRB_RECOVER иииии0*DELAY_FACTOR
97157a #define DELAY_ALE_SETTLE ииииии0*DELAY_FACTOR
07d8af #define DELAY_ADRSEL2_SETTLE ии0*DELAY_FACTOR
b9874e #define DELAY_ADRSEL1_SETTLE ии0*DELAY_FACTOR
ecaf5a
d72e32 #define ioDelay(delayTime) ииии{} ииииииииииииииииииии/* insert delay if rqd */
d5af5a
08af5a
fcc96f #ifdef _MSC_VER
f438e5 /*
6a5039 и* иMicrosoft C++ Direct I/O Functions
b0495d и*/
aa4429 static int inportb(int portNum) {
4599d0 ииunsigned char rval;
5a8d6b ииunsigned short portNumShort = (unsigned short)portNum;
acaf5a
7948ba ии_asm { mov dx,portNumShort }
--80c3 000e63846a280020005 Page 2 of chipio.c
05a1b8 ии_asm { in al,dx }
390458 ии_asm { mov rval, al }
5b76c9 ииreturn (rval);
aeefe6 }
09af5a
0f9285 static void outportb(int portNum, int val) {
3355b6 ииunsigned char valChar = (unsigned char)val;
0b8d6b ииunsigned short portNumShort = (unsigned short)portNum;
64af5a
ac005a ии_asm { mov dx, portNumShort }
6893dc ии_asm { mov al, valChar }
1affc5 ии_asm { out dx, al }
a5efe6 }
987454 #endif
e0af5a
f0af5a
04d629 static void ConfigureIO_Port(int inputOrOutput) {
37d170 ииoutportb(IO_CNFG_ADDRESS, inputOrOutput);
a43113 ииCURRENT_PORT_CNFG = inputOrOutput;
7eaf5a
226c42 ии/* иWarning:
022fbb иии*
38d9be иии* иChanging the IO port state causes a tiny glitch to go out on the
61e818 иии* иPC-DIO card. иThis is enough to ocasionally trigger the ALE, which
0f2e99 иии* иcauses read/write errors. иTo avoid this, always explicitly
dcbbe3 иии* иre-select the chip after switching port directions.
8cf9a6 иии*/
96e4d4 ииCURRENT_CHIP = -1;
71efe6 }
dcaf5a
bbaf5a
334e16 static void SetAddress(int addressValue) {
b354f5 ииoutportb(IO_PORTA_ADDRESS, addressValue);
85efe6 }
1caf5a
49af5a
2952e2 static void SetData(int dataValue) {
e81c12 ииoutportb(IO_PORTB_ADDRESS, dataValue);
20efe6 }
6aaf5a
08af5a
1db8ab static int GetData(void) {
5899a6 ииreturn (inportb(IO_PORTB_ADDRESS));
67efe6 }
98af5a
ebaf5a
c6415d static void SetControl(int controlPortValue) {
186000 ии/*
9f0c74 иии* Possible optimization: Don't send value if already correct.
a1f9a6 иии*/
029b83 ииoutportb(IO_PORTC_ADDRESS, controlPortValue);
b4efe6 }
83af5a
a8b6a1 static void selectBoard(int board) {
23c7b8 ииSetAddress(board);
92b28f ииSetControl(CTRL_BASE ^ CTRL_ADRSEL1); иии/* put board ID onto address pins */
bcec59 ииioDelay(max(DELAY_ADDRESS_SETTLE, DELAY_ADRSEL1_SETTLE)); иииииииии/* wait */
2baf5a
485205 ииSetControl(CTRL_BASE ^ CTRL_ADRSEL1 ^ CTRL_ALE); иииииииии/* pull ALE high */
d81486 ииioDelay(DELAY_ALE_SETTLE); ииииииииииииииииииииииииииииииииииииииии/* wait */
14af5a
797450 ииSetControl(CTRL_BASE ^ CTRL_ADRSEL1); ииииииииииииииииииии/* pull ALE back */
fc1486 ииioDelay(DELAY_ALE_SETTLE); ииииииииииииииииииииииииииииииииииииииии/* wait */
36af5a
7c9619 ииSetControl(CTRL_BASE); ииииииииииииииииииииииииииииииииииии/* ADRSEL1 done */
b11e79 ииioDelay(DELAY_ADRSEL1_SETTLE);
39af5a
647dd7 ииCURRENT_BOARD = board;
14d3d3 ииCURRENT_CHIP и= -1;
c4efe6 }
5baf5a
e6af5a
--bfd3 000429a03bf80020005 Page 3 of chipio.c
bc4c68 static void selectChip(int chip) {
72cb81 ииSetAddress(chip); ииииииииииииииииииииииииииииииииииииииииии/* select chip */
3ca47d ииioDelay(DELAY_ADDRESS_SETTLE); ииииииииииииииииииииииииииииииииииии/* wait */
caaf5a
1ad034 ииSetControl(CTRL_BASE ^ CTRL_ALE); ииииииииииииииииииииииии/* pull ALE high */
fc1486 ииioDelay(DELAY_ALE_SETTLE); ииииииииииииииииииииииииииииииииииииииии/* wait */
f4af5a
917415 ииSetControl(CTRL_BASE); иииииииииииииииииииииииииииииииииии/* pull ALE back */
9b1486 ииioDelay(DELAY_ALE_SETTLE); ииииииииииииииииииииииииииииииииииииииии/* wait */
85af5a
fb6496 ииCURRENT_CHIP = chip;
4fefe6 }
d6af5a
8baf5a
d13072 void SetBaseAddress(int address) {
eee199 ииIO_BASE_ADDRESS = address;
21efe6 }
34af5a
a7af5a
1a38e5 /*
2c052d и* иRESET A SINGLE BOARD
8a775e и*
810727 и* иThis function resets an entire board. It is not optimized for speed.
c18338 и* иIt is necessary to delay after calling this function until the board
30b84c и* иreset completes.
11495d и*/
6aa7b4 int ResetBoard(int board) {
66af5a
65da81 ии/* Configure the IO card (doesn't matter if for data input or output) */
0488b6 ииConfigureIO_Port(CNFG_INPUT); ииииииииииииииииииии/* configure the IO port */
3c750b ииConfigureIO_Port(CNFG_OUTPUT); иииииииииииииииииии/* configure the IO port */
0daf5a
23fbb6 ииselectBoard(board); иииииииииииииииииииииииииииииииииии/* select the board */
3daf5a
350fd9 ииSetControl(CTRL_BASE ^ CTRL_RST); ииииииииииииииииииииии/* RESET THE BOARD */
fd9c65 ииioDelay(DELAY_RST_HOLD); ииииииииииииииииииииииииииииииииииииииииии/* wait */
c33f1e ииSetControl(CTRL_BASE); ииииииииииииииииииииииииииииииииии/* stop resetting */
63941c ииioDelay(DELAY_RST_RECOVER); иииииииииииииииииииииииииииииииииииииии/* wait */
09af5a
274a62 ииCURRENT_BOARD = -1; иииииииииииииииииии/* reset this on next IO to be safe */
15e381 ииCURRENT_CHIP и= -1; ииииииииииииииииииииииииииииии/* reset this to be safe */
56c86a ииreturn (0);
52efe6 }
65af5a
46af5a
dd070c void SetRegister(int board, int chip, int reg, int value) {
b637bb ииif (CURRENT_PORT_CNFG != CNFG_OUTPUT) иииии/* set IO data lines for output */
a221ba ииииConfigureIO_Port(CNFG_OUTPUT);
5277f8 ииif (CURRENT_BOARD != board) ииииииииииииииии/* make sure board is selected */
5e72c3 ииииselectBoard(board);

cad37b ииif (CURRENT_CHIP != chip) иииииииииииииииииии/* make sure chip is selected */
ae038d ииииselectChip(chip);
afaf5a
72a826 ииSetAddress(reg); ииииииииииииииииииииииииииииии/* select the right address */
2e3549 ииSetData(value); ииииииииииииииииииииииииииииииииииииииии/* output the data */
1d964b ииSetControl(CTRL_BASE ^ CTRL_ADRSEL2); иииииииииииииииииииииииии/* pull low */
a0fc7b ииioDelay(max(max(DELAY_ADDRESS_SETTLE,DELAY_DATA_SETTLE), ииииииииии/* wait */
8a43b6 ииииииииииDELAY_ADRSEL2_SETTLE));
bb7938 ииSetControl(CTRL_BASE ^ CTRL_WRB ^ CTRL_ADRSEL2); ииииииииии/* pull WRB low */
72a1d3 ииioDelay(DELAY_WRB_HOLD); иииииииииииииииииииииииииииииииииииииии/* hold it */
623cfe ииSetControl(CTRL_BASE ^ CTRL_ADRSEL2); иииииииииииииии/* let WRB high again */
060257 ииioDelay(DELAY_WRB_RECOVER); иииииииииииииииииииииииииииииииииииииии/* wait */
3ab463 ииSetControl(CTRL_BASE); ииииииииииииииииииииииииииииии/* let WRB high again */
ab684d ииioDelay(DELAY_ADRSEL2_SETTLE); ииииииииииииииииииииииииииииииииииии/* wait */
c6efe6 }
dcaf5a
2890e3 int GetRegister(int board, int chip, int reg) {
7a07b4 ииint rval;
c6af5a
0af350 ииif (CURRENT_PORT_CNFG != CNFG_INPUT) иииииии/* set IO data lines for input */
f6b51f ииииConfigureIO_Port(CNFG_INPUT);
4277f8 ииif (CURRENT_BOARD != board) ииииииииииииииии/* make sure board is selected */
--7ae2 001a1c4541e80020005 Page 4 of chipio.c
5772c3 ииииselectBoard(board);
c0d37b ииif (CURRENT_CHIP != chip) иииииииииииииииииии/* make sure chip is selected */
2c038d ииииselectChip(chip);
c8af5a
e2a826 ииSetAddress(reg); ииииииииииииииииииииииииииииии/* select the right address */
8f23d4 ииSetControl(CTRL_BASE ^ CTRL_ADRSEL2); иииииииииииииииии/* pull adrsel2 low */
2275ff ииioDelay(max(DELAY_ADDRESS_SETTLE, DELAY_ADRSEL2_SETTLE)); иииииииии/* wait */
6fe7c0 ииSetControl(CTRL_BASE ^ CTRL_RDB ^ CTRL_ADRSEL2); ииииииииии/* pull RDB low */
fa8603 ииioDelay(DELAY_RDB_HOLD);
5ec058 ииrval = GetData();
bbc573 ииSetControl(CTRL_BASE ^ CTRL_ADRSEL2); иииииииииииииииииииии/* let RDB high */
c22935 ииioDelay(DELAY_RDB_RECOVER);
6dafb3 ииSetControl(CTRL_BASE); ииииииииииииииииииииииииииииииии/* let ADRSEL2 high */
9ae0ca ииioDelay(DELAY_ADRSEL2_SETTLE);
25af5a
2b76c9 ииreturn (rval);
60efe6 }
17af5a
90b207 int CheckRegister(int board, int chip, int reg, int value) {
4717e0 ииint i;
25af5a
9a0cd1 ииi = GetRegister(board, chip, reg);
6a76cd ииif (i != value)
c2400d ииииreturn (-1);
fac86a ииreturn (0);
15efe6 }
a1af5a
--5810 001b3720ca780020006 Page 1 of chipio.h
8d2d03 /*****************************************************************************
1a43fa и* chipio.h иииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииии*
7c1e7f и* ииииииииииииииииииииииииHeader file for chipio.c иииииииииииииииииииииииии*
c629eb и* ииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииии*
7709fc и* иииWritten 1998 by Cryptography Research (http://www.cryptography.com) иии*
218aaf и* ииииииand Paul Kocher for the Electronic Frontier Foundation (EFF). ииииии*
e6caeb и* ииииииPlaced in the public domain by Cryptography Research and EFF. ииииии*
8b4992 и* иTHIS IS UNSUPPORTED FREE SOFTWARE. USE AND DISTRIBUTE AT YOUR OWN RISK. и*
1329eb и* ииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииии*
3fc755 и* иIMPORTANT: U.S. LAW MAY REGULATE THE USE AND/OR EXPORT OF THIS PROGRAM. и*
2329eb и* ииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииии*
2d489b и*****************************************************************************
3229eb и* ииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииии*
046eef и* ииREVISION HISTORY: ииииииииииииииииииииииииииииииииииииииииииииииииииииии*
2b29eb и* ииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииии*
ad28d9 и* ииVersion 1.0: иInitial release by Cryptography Research to EFF. иииииииии*
ba29eb и* ииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииии*
08d8c3 и*****************************************************************************/
a7af5a
f51920 #ifndef __CHIPIO_H
e6d6b9 #define __CHIPIO_H
d8af5a
a32deb #define SEARCH_UNITS_PER_CHIP 24
b9af5a
96c928 #define REG_PTXT_VECTOR иииии(0x00)
5821cd #define REG_PTXT_XOR_MASK иии(0x20)
9db3c1 #define REG_CIPHERTEXT0 иииии(0x28)
211752 #define REG_CIPHERTEXT1 иииии(0x30)
25db81 #define REG_PTXT_BYTE_MASK ии(0x38)
2b107b #define REG_SEARCHINFO ииииии(0x3F)
6db9aa #define REG_SEARCH_KEY(x) иии(0x40 + 8*(x))
c4701d #define REG_SEARCH_STATUS(x) (0x47+8*(x))
69af5a
4bea1c void SetBaseAddress(int address);
6bbdbf int ResetBoard(int board);
b4274a void SetRegister(int board, int chip, int reg, int value);
ba59e9 int GetRegister(int board, int chip, int reg);
6ea7fa int CheckRegister(int board, int chip, int reg, int value);
f8af5a
147454 #endif
b3af5a
--176a 0002909cb8180020007 Page 1 of des.c
8d2d03 /*****************************************************************************
9240d0 и* des.c ииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииии*
a8bcaa и* ииииииииииииииииSoftware Model of ASIC DES Implementation ииииииииииииииии*
9b29eb и* ииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииии*
6ed9a2 и* ииWritten 1995-8 by Cryptography Research (http://www.cryptography.com) ии*
b2c441 и* ииOriginal version by Paul Kocher. Placed in the public domain in 1998. ии*
d34992 и* иTHIS IS UNSUPPORTED FREE SOFTWARE. USE AND DISTRIBUTE AT YOUR OWN RISK. и*
4829eb и* ииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииии*
25c755 и* иIMPORTANT: U.S. LAW MAY REGULATE THE USE AND/OR EXPORT OF THIS PROGRAM. и*
df29eb и* ииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииии*
ce489b и*****************************************************************************
8229eb и* ииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииии*
6015cb и* ииIMPLEMENTATION NOTES: ииииииииииииииииииииииииииииииииииииииииииииииииии*
2829eb и* ииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииии*
217602 и* ииThis DES implementation adheres to the FIPS PUB 46 spec and produces иии*
a5ad64 и* ииstandard output. иThe internal operation of the algorithm is slightly ии*
bd2a2b и* ииdifferent from FIPS 46. иFor example, bit orderings are reversed иииииии*
fd1be6 и* ии(the right-hand bit is now labelled as bit 0), the S tables have иииииии*
bab9c7 и* ииrearranged to simplify implementation, and several permutations have иии*
e3c21e и* ииbeen inverted. иFor simplicity and to assist with testing of hardware ии*
c52d8b и* ииimplementations, code size and performance optimizations are omitted. ии*
5d29eb и* ииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииии*
3c489b и*****************************************************************************
1929eb и* ииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииии*
e76eef и* ииREVISION HISTORY: ииииииииииииииииииииииииииииииииииииииииииииииииииииии*
d229eb и* ииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииии*
ccc443 и* ииVersion 1.0: иInitial release и-- PCK. иииииииииииииииииииииииииииииииии*
7bb74c и* ииVersion 1.1: иAltered DecryptDES exchanges to match EncryptDES. -- PCK и*
425c27 и* ииVersion 1.2: иMinor edits and beautifications. и-- PCK иииииииииииииииии*
03d930 и* ииVersion 1.3: иChanges and edits for EFF DES Cracker project. иииииииииии*
ad29eb и* ииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииии*
83d8c3 и*****************************************************************************/
e8af5a
bffeb2 #include <stdio.h>
45bea3 #include <stdlib.h>
2e324c #include <string.h>
0a2bac #include "des.h"
32af5a
557461 static void ComputeRoundKey(bool roundKey[56], bool key[56]);
2884a3 static void RotateRoundKeyLeft(bool roundKey[56]);
9bccfa static void RotateRoundKeyRight(bool roundKey[56]);
611504 static void ComputeIP(bool L[32], bool R[32], bool inBlk[64]);
3707da static void ComputeFP(bool outBlk[64], bool L[32], bool R[32]);
46017b static void ComputeF(bool fout[32], bool R[32], bool roundKey[56]);
3694fe static void ComputeP(bool output[32], bool input[32]);
ab7fae static void ComputeS_Lookup(int k, bool output[4], bool input[6]);
6aabe7 static void ComputePC2(bool subkey[48], bool roundKey[56]);
a3fd9c static void ComputeExpansionE(bool expandedBlock[48], bool R[32]);
ba2f30 static void DumpBin(char *str, bool *b, int bits);
8c43bc static void Exchange_L_and_R(bool L[32], bool R[32]);
87af5a
27a0e5 static int EnableDumpBin = 0;
02af5a
bdaf5a
ceaf5a
964d6c /**********************************************************************/
dec68f /* иииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииии*/
933c1a /* иииииииииииииииииииииииииииDES TABLES иииииииииииииииииииииииииииии*/
46c68f /* иииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииии*/
094d6c /**********************************************************************/
3daf5a
b1af5a
7538e5 /*
f6556a и* иIP: Output bit table_DES_IP[i] equals input bit i.
a3495d и*/
51c166 static int table_DES_IP[64] = {
4f9d69 ииии39, и7, 47, 15, 55, 23, 63, 31,
b9c827 ииии38, и6, 46, 14, 54, 22, 62, 30,
f038ae ииии37, и5, 45, 13, 53, 21, 61, 29,
5c6de0 ииии36, и4, 44, 12, 52, 20, 60, 28,
86b247 ииии35, и3, 43, 11, 51, 19, 59, 27,
29e709 ииии34, и2, 42, 10, 50, 18, 58, 26,
--e1e6 00020a1a00d80020007 Page 2 of des.c
a5829e ииии33, и1, 41, и9, 49, 17, 57, 25,
c511ff ииии32, и0, 40, и8, 48, 16, 56, 24
b482f7 };
a1af5a
0caf5a
6738e5 /*
b248ca и* иFP: Output bit table_DES_FP[i] equals input bit i.
11495d и*/
eadd2a static int table_DES_FP[64] = {
225b71 ииии57, 49, 41, 33, 25, 17, и9, и1,
d98cd9 ииии59, 51, 43, 35, 27, 19, 11, и3,
e79996 ииии61, 53, 45, 37, 29, 21, 13, и5,
6eb571 ииии63, 55, 47, 39, 31, 23, 15, и7,
c50e3f ииии56, 48, 40, 32, 24, 16, и8, и0,
91d997 ииии58, 50, 42, 34, 26, 18, 10, и2,
8dccd8 ииии60, 52, 44, 36, 28, 20, 12, и4,
514da9 ииии62, 54, 46, 38, 30, 22, 14, и6
6f82f7 };
47af5a
20af5a
8038e5 /*
3cda05 и* иPC1: Permutation choice 1, used to pre-process the key
d4495d и*/
c00c38 static int table_DES_PC1[56] = {
8bb89e ииии27, 19, 11, 31, 39, 47, 55,
8728e4 ииии26, 18, 10, 30, 38, 46, 54,
9c8d2c ииии25, 17, и9, 29, 37, 45, 53,
e21d56 ииии24, 16, и8, 28, 36, 44, 52,
37bf91 ииии23, 15, и7, и3, 35, 43, 51,
a62feb ииии22, 14, и6, и2, 34, 42, 50,
5c91e6 ииии21, 13, и5, и1, 33, 41, 49,
fad02f ииии20, 12, и4, и0, 32, 40, 48
b082f7 };
55af5a
dfaf5a
8438e5 /*
45f37a и* иPC2: Map 56-bit round key to a 48-bit subkey
0a495d и*/
047fcf static int table_DES_PC2[48] = {
498889 ииии24, 27, 20, и6, 14, 10, и3, 22,
2e30a5 иииии0, 17, и7, 12, и8, 23, 11, и5,
c23fa5 ииии16, 26, и1, и9, 19, 25, и4, 15,
3ce272 ииии54, 43, 36, 29, 49, 40, 48, 30,
646356 ииии52, 44, 37, 33, 46, 35, 50, 41,
207786 ииии28, 53, 51, 55, 32, 45, 39, 42
aa82f7 };
ffaf5a
d1af5a
d838e5 /*
1cdb31 и* иE: Expand 32-bit R to 48 bits.
76495d и*/
ac6a87 static int table_DES_E[48] = {
fae6fb ииии31, и0, и1, и2, и3, и4, и3, и4,
f62634 иииии5, и6, и7, и8, и7, и8, и9, 10,
95d06b ииии11, 12, 11, 12, 13, 14, 15, 16,
4b7fa0 ииии15, 16, 17, 18, 19, 20, 19, 20,
cf4d0d ииии21, 22, 23, 24, 23, 24, 25, 26,
d09708 ииии27, 28, 27, 28, 29, 30, 31, и0
4082f7 };
4faf5a
eeaf5a
ae38e5 /*
bcc34a и* иP: Permutation of S table outputs
b7495d и*/
365137 static int table_DES_P[32] = {
15f612 ииии11, 17, и5, 27, 25, 10, 20, и0,
d0b9f8 ииии13, 21, и3, 28, 29, и7, 18, 24,
18cde3 ииии31, 22, 12, и6, 26, и2, 16, и8,
9b60a7 ииии14, 30, и4, 19, и1, и9, 15, 23
4482f7 };
ceaf5a
20af5a
--f1a0 000f7378b1880020007 Page 3 of des.c
bc38e5 /*
8e6f34 и* иS Tables: Introduce nonlinearity and avalanche
a3495d и*/
a11e19 static int table_DES_S[8][64] = {
3cd69a ииии/* table S[0] */
e4846d ииииииии{ ии13, и1, и2, 15, и8, 13, и4, и8, и6, 10, 15, и3, 11, и7, и1, и4,
c965af ииииииииииии10, 12, и9, и5, и3, и6, 14, 11, и5, и0, и0, 14, 12, и9, и7, и2,
95d5b0 иииииииииииии7, и2, 11, и1, и4, 14, и1, и7, и9, и4, 12, 10, 14, и8, и2, 13,
8c3ee1 иииииииииииии0, 15, и6, 12, 10, и9, 13, и0, 15, и3, и3, и5, и5, и6, и8, 11 и},
11d2b1 ииии/* table S[1] */
d54b6a ииииииии{ иии4, 13, 11, и0, и2, 11, 14, и7, 15, и4, и0, и9, и8, и1, 13, 10,
98df4d иииииииииииии3, 14, 12, и3, и9, и5, и7, 12, и5, и2, 10, 15, и6, и8, и1, и6,
35f575 иииииииииииии1, и6, и4, 11, 11, 13, 13, и8, 12, и1, и3, и4, и7, 10, 14, и7,
7b6234 ииииииииииии10, и9, 15, и5, и6, и0, и8, 15, и0, 14, и5, и2, и9, и3, и2, 12 и},
d2decc ииии/* table S[2] */
1ef108 ииииииии{ ии12, 10, и1, 15, 10, и4, 15, и2, и9, и7, и2, 12, и6, и9, и8, и5,
9bd582 иииииииииииии0, и6, 13, и1, и3, 13, и4, 14, 14, и0, и7, 11, и5, и3, 11, и8,
7f0bbf иииииииииииии9, и4, 14, и3, 15, и2, и5, 12, и2, и9, и8, и5, 12, 15, и3, 10,
9a7505 иииииииииииии7, 11, и0, 14, и4, и1, 10, и7, и1, и6, 13, и0, 11, и8, и6, 13 и},
68dae7 ииии/* table S[3] */
305c4d ииииииии{ иии2, 14, 12, 11, и4, и2, и1, 12, и7, и4, 10, и7, 11, 13, и6, и1,
d80156 иииииииииииии8, и5, и5, и0, и3, 15, 15, 10, 13, и3, и0, и9, 14, и8, и9, и6,
37f5dc иииииииииииии4, 11, и2, и8, и1, 12, 11, и7, 10, и1, 13, 14, и7, и2, и8, 13,
ded332 ииииииииииии15, и6, и9, 15, 12, и0, и5, и9, и6, 10, и3, и4, и0, и5, 14, и3 и},
5fc636 ииии/* table S[4] */
ef4850 ииииииии{ иии7, 13, 13, и8, 14, 11, и3, и5, и0, и6, и6, 15, и9, и0, 10, и3,
14f1a6 иииииииииииии1, и4, и2, и7, и8, и2, и5, 12, 11, и1, 12, 10, и4, 14, 15, и9,
45f43f ииииииииииии10, и3, и6, 15, и9, и0, и0, и6, 12, 10, 11, и1, и7, 13, 13, и8,
9ed830 ииииииииииии15, и9, и1, и4, и3, и5, 14, 11, и5, 12, и2, и7, и8, и2, и4, 14 и},
49c21d ииии/* table S[5] */
b1ea9b ииииииии{ ии10, 13, и0, и7, и9, и0, 14, и9, и6, и3, и3, и4, 15, и6, и5, 10,
03bd2c иииииииииииии1, и2, 13, и8, 12, и5, и7, 14, 11, 12, и4, 11, и2, 15, и8, и1,
bed567 ииииииииииии13, и1, и6, 10, и4, 13, и9, и0, и8, и6, 15, и9, и3, и8, и0, и7,
3b8261 ииииииииииии11, и4, и1, 15, и2, 14, 12, и3, и5, 11, 10, и5, 14, и2, и7, 12 и},
c3ce60 ииии/* table S[6] */
69a636 ииииииии{ ии15, и3, и1, 13, и8, и4, 14, и7, и6, 15, 11, и2, и3, и8, и4, 14,
38ac1c иииииииииииии9, 12, и7, и0, и2, и1, 13, 10, 12, и6, и0, и9, и5, 11, 10, и5,
6b7311 иииииииииииии0, 13, 14, и8, и7, 10, 11, и1, 10, и3, и4, 15, 13, и4, и1, и2,
a8b1aa иииииииииииии5, 11, и8, и6, 12, и7, и6, 12, и9, и0, и3, и5, и2, 14, 15, и9 и},
ceca4b ииии/* table S[7] */
68cf66 ииииииии{ ии14, и0, и4, 15, 13, и7, и1, и4, и2, 14, 15, и2, 11, 13, и8, и1,
7baacb иииииииииииии3, 10, 10, и6, и6, 12, 12, 11, и5, и9, и9, и5, и0, и3, и7, и8,
4d2f45 иииииииииииии4, 15, и1, 12, 14, и8, и8, и2, 13, и4, и6, и9, и2, и1, 11, и7,
3f2777 ииииииииииии15, и5, 12, 11, и9, и3, и7, 14, и3, 10, 10, и0, и5, и6, и0, 13 и}
1882f7 };
34af5a
55af5a
e6af5a
fcaf5a
d34d6c /**********************************************************************/
dec68f /* иииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииии*/
fbcabf /* ииииииииииииииииииииииииииииDES CODE ииииииииииииииииииииииииииииии*/
ffc68f /* иииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииии*/
474d6c /**********************************************************************/
8eaf5a
5baf5a
2a38e5 /*
0fb080 и* иEncryptDES: Encrypt a block using DES. Set verbose for debugging info.
4d770b и* и(This loop does both loops on the "DES Encryption" page of the flowchart.)
22495d и*/
da5620 void EncryptDES(bool key[56], bool outBlk[64], bool inBlk[64], int verbose) {
062b1c ииint i,round;
909aa1 ииbool R[32], L[32], fout[32];
6fbfaf ииbool roundKey[56];
d8af5a
9b1294 ииEnableDumpBin = verbose; иииииииииииииииииииии/* set debugging on/off flag */
3ccb2a ииDumpBin("input(left)", inBlk+32, 32);
728fb2 ииDumpBin("input(right)", inBlk, 32);
490a8e ииDumpBin("raw key(left )", key+28, 28);
d75585 ииDumpBin("raw key(right)", key, 28);
ffaf5a
f7c1be ии/* Compute the first roundkey by performing PC1 */
--1527 00053c1ed1980020007 Page 4 of des.c
47b264 ииComputeRoundKey(roundKey, key);
53af5a
0295d4 ииDumpBin("roundKey(L)", roundKey+28, 28);
840a5f ииDumpBin("roundKey(R)", roundKey, 28);
48af5a
e81340 ии/* Compute the initial permutation and divide the result into L and R */
1ad1a8 ииComputeIP(L,R,inBlk);
aeaf5a
7777ba ииDumpBin("after IP(L)", L, 32);
cc7699 ииDumpBin("after IP(R)", R, 32);
baaf5a
1ff437 ииfor (round = 0; round < 16; round++) {
4421bf ииииif (verbose)
a491a0 ииииииprintf("-------------- BEGIN ENCRYPT ROUND %d -------------\n", round);
838034 ииииDumpBin("round start(L)", L, 32);
628117 ииииDumpBin("round start(R)", R, 32);
d2af5a
8b7fc3 ииии/* Rotate roundKey halves left once or twice (depending on round) */
aec8ba ииииRotateRoundKeyLeft(roundKey);
9b1467 ииииif (round != 0 && round != 1 && round != 8 && round != 15)
1950e7 ииииииRotateRoundKeyLeft(roundKey);
003cd7 ииииDumpBin("roundKey(L)", roundKey+28, 28);
bb1bd4 ииииDumpBin("roundKey(R)", roundKey, 28);
82af5a
e0033b ииии/* Compute f(R, roundKey) and exclusive-OR onto the value in L */
14d969 ииииComputeF(fout, R, roundKey);
5c54e7 ииииDumpBin("f(R,key)", fout, 32);
4a4739 ииииfor (i = 0; i < 32; i++)
2ba9e6 ииииииL[i] ^= fout[i];
a5a5ab ииииDumpBin("L^f(R,key)", L, 32);
56af5a
7a68b4 ииииExchange_L_and_R(L,R);
3aaf5a
a3a140 ииииDumpBin("round end(L)", L, 32);
fca063 ииииDumpBin("round end(R)", R, 32);
4b21bf ииииif (verbose)
a24514 ииииииprintf("--------------- END ROUND %d --------------\n", round);
66df1c ии}
d9af5a
5e8e68 ииExchange_L_and_R(L,R);
87af5a
71370b ии/* Combine L and R then compute the final permutation */
77cf94 ииComputeFP(outBlk,L,R);
468b91 ииDumpBin("FP out( left)", outBlk+32, 32);
cbf675 ииDumpBin("FP out(right)", outBlk, 32);
b0efe6 }
43af5a
15af5a
01af5a
e038e5 /*
1e9b68 и* иDecryptDES: Decrypt a block using DES. Set verbose for debugging info.
6fa5c7 и* и(This loop does both loops on the "DES Decryption" page of the flowchart.)
1a495d и*/
b66de8 void DecryptDES(bool key[56], bool outBlk[64], bool inBlk[64], int verbose) {
b82b1c ииint i,round;
299aa1 ииbool R[32], L[32], fout[32];
f9bfaf ииbool roundKey[56];
24af5a
5a1294 ииEnableDumpBin = verbose; иииииииииииииииииииии/* set debugging on/off flag */
96cb2a ииDumpBin("input(left)", inBlk+32, 32);
4b8fb2 ииDumpBin("input(right)", inBlk, 32);
f60a8e ииDumpBin("raw key(left )", key+28, 28);
395585 ииDumpBin("raw key(right)", key, 28);
82af5a
8cc1be ии/* Compute the first roundkey by performing PC1 */
a4b264 ииComputeRoundKey(roundKey, key);
dcaf5a
5f95d4 ииDumpBin("roundKey(L)", roundKey+28, 28);
300a5f ииDumpBin("roundKey(R)", roundKey, 28);
33af5a
291340 ии/* Compute the initial permutation and divide the result into L and R */
53d1a8 ииComputeIP(L,R,inBlk);
--1f01 0005e2de84280020007 Page 5 of des.c
e0af5a
7177ba ииDumpBin("after IP(L)", L, 32);
3d7699 ииDumpBin("after IP(R)", R, 32);
96af5a
3cf437 ииfor (round = 0; round < 16; round++) {
3d21bf ииииif (verbose)
ff2cb4 ииииииprintf("-------------- BEGIN DECRYPT ROUND %d -------------\n", round);

528034 ииииDumpBin("round start(L)", L, 32);
e78117 ииииDumpBin("round start(R)", R, 32);
22af5a
d3033b ииии/* Compute f(R, roundKey) and exclusive-OR onto the value in L */
06d969 ииииComputeF(fout, R, roundKey);
dc54e7 ииииDumpBin("f(R,key)", fout, 32);
b54739 ииииfor (i = 0; i < 32; i++)
eca9e6 ииииииL[i] ^= fout[i];
dba5ab ииииDumpBin("L^f(R,key)", L, 32);
50af5a
8e68b4 ииииExchange_L_and_R(L,R);
e9af5a
2dc90d ииии/* Rotate roundKey halves right once or twice (depending on round) */
3210bc ииииDumpBin("roundKey(L)", roundKey+28, 28); ииииии/* show keys before shift */
be1bd4 ииииDumpBin("roundKey(R)", roundKey, 28);
3df5db ииииRotateRoundKeyRight(roundKey);
6711ff ииииif (round != 0 && round != 7 && round != 14 && round != 15)
f97c23 ииииииRotateRoundKeyRight(roundKey);
02af5a
cea140 ииииDumpBin("round end(L)", L, 32);
7ba063 ииииDumpBin("round end(R)", R, 32);
4321bf ииииif (verbose)
f04514 ииииииprintf("--------------- END ROUND %d --------------\n", round);
3fdf1c ии}
61af5a
738e68 ииExchange_L_and_R(L,R);
71af5a
b9370b ии/* Combine L and R then compute the final permutation */
b9cf94 ииComputeFP(outBlk,L,R);
b08b91 ииDumpBin("FP out( left)", outBlk+32, 32);
c1f675 ииDumpBin("FP out(right)", outBlk, 32);
7cefe6 }
59af5a
9aaf5a
1daf5a
a938e5 /*
bd8d8b и* иComputeRoundKey: Compute PC1 on the key and store the result in roundKey
6c495d и*/
94988e static void ComputeRoundKey(bool roundKey[56], bool key[56]) {
fe17e0 ииint i;
afaf5a
be815b ииfor (i = 0; i < 56; i++)
46d64b ииииroundKey[table_DES_PC1[i]] = key[i];
f3efe6 }
1aaf5a
4caf5a
b3af5a
af38e5 /*
3555cb и* иRotateRoundKeyLeft: Rotate each of the halves of roundKey left one bit
42495d и*/
af7d60 static void RotateRoundKeyLeft(bool roundKey[56]) {
e4483e ииbool temp1, temp2;
c717e0 ииint i;
88af5a
9bf689 ииtemp1 = roundKey[27];
3efe1b ииtemp2 = roundKey[55];
bb300b ииfor (i = 27; i >= 1; i--) {
43575a ииииroundKey[i] = roundKey[i-1];
b53242 ииииroundKey[i+28] = roundKey[i+28-1];
7adf1c ии}
4d7b9f ииroundKey[ 0] = temp1;
e0cf9d ииroundKey[28] = temp2;
a8efe6 }
f3af5a
5eaf5a
--1bb7 0002e9cf80d80020007 Page 6 of des.c
e0af5a
d338e5 /*
7dc6ad и* иRotateRoundKeyRight: Rotate each of the halves of roundKey right one bit
f9495d и*/
1ab26c static void RotateRoundKeyRight(bool roundKey[56]) {
7d483e ииbool temp1, temp2;
1517e0 ииint i;
c0af5a
7a5025 ииtemp1 = roundKey[0];
9c4548 ииtemp2 = roundKey[28];
5fe568 ииfor (i = 0; i < 27; i++) {
196cc2 ииииroundKey[i] = roundKey[i+1];
7809da ииииroundKey[i+28] = roundKey[i+28+1];
ecdf1c ии}
dfa88d ииroundKey[27] = temp1;
945d11 ииroundKey[55] = temp2;
e3efe6 }
2caf5a
41af5a
38af5a
7738e5 /*
a32903 и* иComputeIP: Compute the initial permutation and split into L and R halves.
df495d и*/
23ac44 static void ComputeIP(bool L[32], bool R[32], bool inBlk[64]) {
686085 ииbool output[64];
d417e0 ииint i;
a3af5a
77aeaf ии/* Permute
07f9a6 иии*/
4e6406 ииfor (i = 63; i >= 0; i--)
adc750 ииииoutput[table_DES_IP[i]] = inBlk[i];
95af5a

500318 ии/* Split into R and L. иBits 63..32 go in L, bits 31..0 go in R.
70f9a6 иии*/
daba85 ииfor (i = 63; i >= 0; i--) {
d40368 ииииif (i >= 32)
3ef2b8 ииииииL[i-32] = output[i];
60842c ииииelse
b070b5 ииииииR[i] = output[i];
86df1c ии}
f5efe6 }
4baf5a
70af5a
2aaf5a
3738e5 /*
8e4ffe и* иComputeFP: Combine the L and R halves and do the final permutation.
51495d и*/
d193a5 static void ComputeFP(bool outBlk[64], bool L[32], bool R[32]) {
f342e9 ииbool input[64];
5c17e0 ииint i;
08af5a
2c6c41 ии/* Combine L and R into input[64]
45f9a6 иии*/
916406 ииfor (i = 63; i >= 0; i--)
878397 ииииinput[i] = (i >= 32) ? L[i - 32] : R[i];
8caf5a
d3aeaf ии/* Permute
98f9a6 иии*/
1c6406 ииfor (i = 63; i >= 0; i--)
85e116 ииииoutBlk[table_DES_FP[i]] = input[i];
bcefe6 }
18af5a
beaf5a
a8af5a
5e38e5 /*
90810f и* иComputeF: Compute the DES f function and store the result in fout.
01495d и*/
0c2720 static void ComputeF(bool fout[32], bool R[32], bool roundKey[56]) {
a3f6a2 ииbool expandedBlock[48], subkey[48], sout[32];
adbbe6 ииint i,k;
d9af5a
2e1a04 ии/* Expand R into 48 bits using the E expansion */
--92d2 000e8f1171f80020007 Page 7 of des.c
fb99d7 ииComputeExpansionE(expandedBlock, R);
e5f0ba ииDumpBin("expanded E", expandedBlock, 48);
efaf5a
7693ff ии/* Convert the roundKey into the subkey using PC2 */
4a7840 ииComputePC2(subkey, roundKey);
21d717 ииDumpBin("subkey", subkey, 48);
39af5a
e5154c ии/* XOR the subkey onto the expanded block */
bffcab ииfor (i = 0; i < 48; i++)
2d6512 ииииexpandedBlock[i] ^= subkey[i];
fbaf5a
340740 ии/* Divide expandedBlock into 6-bit chunks and do S table lookups */
0225c6 ииfor (k = 0; k < 8; k++)
e985c7 ииииComputeS_Lookup(k, sout+4*k, expandedBlock+6*k);
67af5a
dbfd35 ии/* To complete the f() calculation, do permutation P on the S table output */
6d2d52 ииComputeP(fout, sout);
b3efe6 }
0caf5a
76af5a
d3af5a
5538e5 /*
eb913f и* иComputeP: Compute the P permutation on the S table outputs.
52495d и*/
61f410 static void ComputeP(bool output[32], bool input[32]) {
3b17e0 ииint i;
20af5a
b5339a ииfor (i = 0; i < 32; i++)
3f7688 ииииoutput[table_DES_P[i]] = input[i];
b1efe6 }
10af5a
94af5a
70af5a
5b38e5 /*
8a859b и* иLook up a 6-bit input in S table k and store the result as a 4-bit output.
ad495d и*/
49a67e static void ComputeS_Lookup(int k, bool output[4], bool input[6]) {
9bf3da ииint inputValue, outputValue;
a5af5a
ad1a9e ии/* Convert the input bits into an integer */
6afccb ииinputValue = input[0] + 2*input[1] + 4*input[2] + 8*input[3] +
f18c1a ииииииииии16*input[4] + 32*input[5];
3faf5a
164a3e ии/* Do the S table lookup */
34b706 ииoutputValue = table_DES_S[k][inputValue];
4baf5a
0a8aed ии/* Convert the result into binary form */
0c9a60 ииoutput[0] = (outputValue & 1) ? 1 : 0;
3a6aec ииoutput[1] = (outputValue & 2) ? 1 : 0;
d9f487 ииoutput[2] = (outputValue & 4) ? 1 : 0;
708c7f ииoutput[3] = (outputValue & 8) ? 1 : 0;
95efe6 }
dfaf5a
78af5a
d2af5a
0338e5 /*
8181cc и* иComputePC2: Map a 56-bit round key onto a 48-bit subkey
2a495d и*/
22796f static void ComputePC2(bool subkey[48], bool roundKey[56]) {
2817e0 ииint i;
d0af5a
17fcab ииfor (i = 0; i < 48; i++)
bec8bc ииииsubkey[i] = roundKey[table_DES_PC2[i]];
16efe6 }
67af5a
c5af5a
43af5a
2838e5 /*
20459d и* иComputeExpansionE: Compute the E expansion to prepare to use S tables.
b8495d и*/
4bb46d static void ComputeExpansionE(bool expandedBlock[48], bool R[32]) {
e817e0 ииint i;
--cf4e 001f263015b80020007 Page 8 of des.c
e0af5a
f3fcab ииfor (i = 0; i < 48; i++)
7db971 ииииexpandedBlock[i] = R[table_DES_E[i]];
0cefe6 }
e0af5a
a1af5a
d8af5a
2e38e5 /*
10f923 и* иExchange_L_and_R: иSwap L and R
08495d и*/
c895d1 static void Exchange_L_and_R(bool L[32], bool R[32]) {
5a17e0 ииint i;
aaaf5a
36339a ииfor (i = 0; i < 32; i++)
b225db ииииL[i] ^= R[i] ^= L[i] ^= R[i]; ииииииииииииииии/* exchanges L[i] and R[i] */
f8efe6 }
3eaf5a
84af5a
60af5a
0038e5 /*
489231 и* иDumpBin: Display intermediate values if emableDumpBin is set.
41495d и*/
1ddbd9 static void DumpBin(char *str, bool *b, int bits) {
6e17e0 ииint i;
56af5a
648af7 ииif ((bits % 4)!=0 || bits>48) {
6db2e5 ииииprintf("Bad call to DumpBin (bits > 48 or bit len not a multiple of 4\n");
5c646c ииииexit(1);
42df1c ии}
8eaf5a
413332 ииif (EnableDumpBin) {
3ff079 ииииfor (i = strlen(str); i < 14; i++)
b7c8c3 ииииииprintf(" ");
655fc3 ииииprintf("%s: ", str);
98eac8 ииииfor (i = bits-1; i >= 0; i--)
d2de5b ииииииprintf("%d", b[i]);
8a3177 ииииprintf(" ");
de821f ииииfor (i = bits; i < 48; i++)
4ec8c3 ииииииprintf(" ");
6b6b57 ииииprintf("(");
a705d7 ииииfor (i = bits-4; i >= 0; i-=4)
0bf78c ииииииprintf("%X", b[i]+2*b[i+1]+4*b[i+2]+8*b[i+3]);
2efa6f ииииprintf(")\n");
04df1c ии}
01efe6 }
f2af5a
--5f71 001ba22687980020008 Page 1 of des.h
8d2d03 /*****************************************************************************
cb1a06 и* des.h ииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииии*
0f4b62 и* ииииииииииииииииииииииииииHeader file for des.c ииииииииииииииииииииииииии*
5c29eb и* ииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииии*
57d9a2 и* ииWritten 1995-8 by Cryptography Research (http://www.cryptography.com) ии*
e9c441 и* ииOriginal version by Paul Kocher. Placed in the public domain in 1998. ии*
f64992 и* иTHIS IS UNSUPPORTED FREE SOFTWARE. USE AND DISTRIBUTE AT YOUR OWN RISK. и*
4329eb и* ииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииии*
ddc755 и* иIMPORTANT: U.S. LAW MAY REGULATE THE USE AND/OR EXPORT OF THIS PROGRAM. и*
3e29eb и* ииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииии*
dd489b и*****************************************************************************
8029eb и* ииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииии*
246eef и* ииREVISION HISTORY: ииииииииииииииииииииииииииииииииииииииииииииииииииииии*
8b29eb и* ииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииии*
00c443 и* ииVersion 1.0: иInitial release и-- PCK. иииииииииииииииииииииииииииииииии*
87f57b и* ииVersion 1.1: иChanges and edits for EFF DES Cracker project. иииииииииии*
6029eb и* ииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииии*
ffd8c3 и*****************************************************************************/
45af5a
9da019 #ifndef __DES_H
828311 #define __DES_H
a3af5a
c608c5 typedef char bool;
909629 void EncryptDES(bool key[56], bool outBlk[64], bool inBlk[64], int verbose);
8e8db3 void DecryptDES(bool key[56], bool outBlk[64], bool inBlk[64], int verbose);
bcaf5a
f27454 #endif
baaf5a
--5736 0007f67bbbf80020009 Page 1 of initsrch.c
8d2d03 /*****************************************************************************
2fe318 и* initsrch.c иииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииии*
fa709c и* иииииииииииииииDES Search Engine Search Definition Program иииииииииииииии*
f829eb и* ииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииии*
5d09fc и* иииWritten 1998 by Cryptography Research (http://www.cryptography.com) иии*
0b8aaf и* ииииииand Paul Kocher for the Electronic Frontier Foundation (EFF). ииииии*
bccaeb и* ииииииPlaced in the public domain by Cryptography Research and EFF. ииииии*
9a4992 и* иTHIS IS UNSUPPORTED FREE SOFTWARE. USE AND DISTRIBUTE AT YOUR OWN RISK. и*
8c29eb и* ииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииии*
72c755 и* иIMPORTANT: U.S. LAW MAY REGULATE THE USE AND/OR EXPORT OF THIS PROGRAM. и*
5329eb и* ииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииии*
cf489b и*****************************************************************************
cb29eb и* ииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииии*
3615cb и* ииIMPLEMENTATION NOTES: ииииииииииииииииииииииииииииииииииииииииииииииииии*
b629eb и* ииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииии*
c6922a и* ииThis program is used to define searches that will be run on the DES ииии*
b77950 и* ииsearch array. иThe program creates a search context file containing ииии*
ec6515 и* ииthe ciphertexts, search parameters, and a list of the key regions ииииии*
6bec7c и* ииto search. и(A key region is the top 24 bits of a key.) ииииииииииииииии*
5829eb и* ииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииии*
a5489b и*****************************************************************************
4229eb и* ииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииии*
d16eef и* ииREVISION HISTORY: ииииииииииииииииииииииииииииииииииииииииииииииииииииии*
c329eb и* ииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииии*
7828d9 и* ииVersion 1.0: иInitial release by Cryptography Research to EFF. иииииииии*
2c29eb и* ииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииии*
aed8c3 и*****************************************************************************/
41af5a
6abcd3 #define SOFTWARE_VERSION "1.0"
55a5c9 #define SOFTWARE_DATE иии"04-21-1998"
02af5a
28af5a
c5feb2 #include <stdio.h>
a2bea3 #include <stdlib.h>
9b1465 #include <conio.h>
49324c #include <string.h>
46c737 #include <memory.h>
2b0a8b #include <time.h>
93b1cb #include <ctype.h>
00c94c #include "search.h"
552ba0 #include "keyblock.h"
ecaf5a
5eb216 #define EXIT_ERR(s) { fprintf(stderr, s); exit(1); }
7146ff static void dumpBin(char *intro, unsigned char *data, int len);
51ab37 static int unhex(unsigned char *data, char *hex, int byteCount);
66af5a
34af5a
e2164b int main(int argc, char **argv) {
551309 ииchar searchType; ииииииииииииииииииииии/* valid search types are K,C,E,B,M */
babcdd ииint nextArg = 1;
7963f8 ииunsigned char plaintext[8];
fa17e0 ииint i;
5fd5d9 ииchar *c, buf[100];
8e83f2 ииSEARCH_CTX ctx;
32154a ииFILE *outfile;
16817e ииchar asciiBytes[] = { и0, 9, 10, 13,' ','!', '\"', '\'','(',')',',','-','.',
cbdc95 иииииииииии'0','1','2','3','4','5','6','7','8','9',':',';','?',
90b0c9 иииииииииии'A','B','C','D','E','F','G','H','I','J','K','L','M',
ea6651 иииииииииии'N','O','P','Q','R','S','T','U','V','W','X','Y','Z','^','_','`',
15790e иииииииииии'a','b','c','d','e','f','g','h','i','j','k','l','m',
78488f иииииииииии'n','o','p','q','r','s','t','u','v','w','x','y','z' };
c7af5a
53ee0f ииprintf("\nDES Search Definition Util. (Ver %s, %s). May be export "
5bffaa иииииииии"controlled.\nWritten 1998 by Cryptography Research "
cf2e08 иииииииии"(http://www.cryptography.com) for EFF.\n"
c5c4fd иииииииии"This is unsupported "
051151 иииииииии"free software: Use and distribute at your own risk.\n"
50805d иииииииии"-------------------------------------------"
d504bf иииииииии"---------------------------------\n\n\n",
8aa1fb иииииииииSOFTWARE_VERSION, SOFTWARE_DATE);
d7af5a
7fcf50 ииif (argc == 1) {
--cfc3 000b6391f9f80020009 Page 2 of initsrch.c
87048b ииииprintf("Parameters can be entered on the command line or entered "
a20e7c иииииииииии"manually.\n\nUsage modes: и(ctxt=ciphertext, ptxt=plaintext)\n"
0ea4b3 иииииииииии" иииdesbrute search.ctx K (8 bytes ptxt) (8 bytes ctxt)\n"
b34c3c иииииииииии" иииdesbrute search.ctx E (8 bytes ctxt0) (8 bytes ctxt1)\n"
192ff0 иииииииииии" иииdesbrute search.ctx C (8 bytes IV) (8 bytes ctxt0) "
289890 иииииииииииииииииииии"(8 bytes ctxt1)\n"
ad835b иииииииииии" иииdesbrute search.ctx B (1 ctxt byte to repeat)\n"
42dba1 иииииииииии" иииdesbrute search.ctx M (ptxtVec) (IV) (ctxt0) (ctxt1)"
171870 иииииииииииииииииииии"(bMask) (schInf)\n\n"
2cf69b иииииииииии"Parameters can also be input from a file (e.g., "
c31498 иииииииииии"\"desbrute < param.in\"\n\n");
36df1c ии}
41af5a
8b3b84 ии/**** OPEN OUTPUT FILE ****/
142284 ииif (argc > nextArg) {
b034d4 ииииc = argv[nextArg++];
5449d8 ии} else {
3da6db ииииprintf("Enter output file for search context [ENTER=\"search.ctx\"]: ");
7e0aa5 ииииgets(buf);
7a5331 ииииif (*buf == '\0')
6ea68e ииииииstrcpy(buf, "search.ctx");
383b52 ииииc = buf;
2bdf1c ии}
e2744c ииoutfile = fopen(c, "wb"); иииииииииииииииииииииииииииии/* open output file */
5c046f ииif (outfile == NULL)
b8eee0 ииииEXIT_ERR("Error opening output file.\n");
27af5a
28f1d1 ии/**** INITALIZE searchType ****/
e92284 ииif (argc > nextArg) {
0534d4 ииииc = argv[nextArg++];
7949d8 ии} else {
1c4645 ииииprintf("The array supports a variety of search types:\n");
893c39 ииииprintf(" ииK - Known plaintext (standard brute force).\n");
458386 ииииprintf(" ииE - ECB ASCII text\n");
ede877 ииииprintf(" ииC - CBC ASCII text\n");
c042f4 ииииprintf(" ииB - Blaze challenge\n");
f72546 ииииprintf(" ииM - Manual parameter specification\n");
457020 ииииprintf("Enter search type: ");
2e98f5 ииииfgets(buf, 99, stdin);
6f3b52 ииииc = buf;
16df1c ии}
bde55a ииsearchType = (char)toupper(c[0]);
1fb2fb ииif (strchr("KECBM", searchType) == NULL)
d09d35 ииииEXIT_ERR("Unknown search type. иExiting.\n");
caaf5a
3653c4 ии/**** INITALIZE PARAMETERS FOR KNOWN PLAINTEXT SEARCHES ****/
b606fd ииif (searchType == 'K') {
40af5a
31beaf ииии/* Get known plaintext */
b6f875 ииииif (argc > nextArg) {
66d208 ииииииc = argv[nextArg++];
2a6a79 ииии} else {
865acf ииииииprintf("Enter known plaintext (16 hex digits): ");
44ec56 ииииииfgets(buf, 99, stdin);
519eec ииииииc = buf;
716fe7 ииии}
3b2686 ииииif (unhex(plaintext, c, 8))
5284f6 ииииииEXIT_ERR("Invalid plaintext. (Must be 16 hex digits)");
43af5a
d154a2 ииии/* Get ciphertext 0 (use same for ciphertext 1) */
99f875 ииииif (argc > nextArg) {
b6d208 ииииииc = argv[nextArg++];
206a79 ииии} else {
116433 ииииииprintf("Enter ciphertext (16 hex digits): ");
ebec56 ииииииfgets(buf, 99, stdin);
d79eec ииииииc = buf;
306fe7 ииии}
a00e9c ииииif (unhex(ctx.ciphertext0, c, 8) || unhex(ctx.ciphertext1, c, 8))
ed301c ииииииEXIT_ERR("Invalid ciphertext. (Must be 16 hex digits.)");
0baf5a
95b74c ииии/* Set ctx */
b6b998 ииииmemset(ctx.plaintextVector, 0, sizeof(ctx.plaintextVector));
--8f53 000bd86da9880020009 Page 3 of initsrch.c
b10371 ииииfor (i = 0; i < 8; i++)
0c2965 ииииииctx.plaintextVector[plaintext[i]/8] |= (1 << (plaintext[i] % 8));
9d09b5 ииииctx.plaintextByteMask = 0x00;
23175f ииииmemset(ctx.plaintextXorMask, 0, sizeof(ctx.plaintextXorMask));
d8f1c6 ииииctx.searchInfo = 16; иииииииииии/* useCBC=0, extraXor=0, boardActiveEn=1 */
73df1c ии}
10af5a
1a6d39 ии/**** INITALIZE PARAMETERS FOR ASCII SEARCHES ****/
0a4571 ииif (searchType == 'E' || searchType == 'C') {
b1af5a
9d92ba ииии/* Get IV (only if this is ciphertext mode) */
dd5306 ииииif (searchType == 'C') {
0ae472 ииииииif (argc > nextArg) {
eaa6ab ииииииииc = argv[nextArg++];
dbcfc7 ииииии} else {
04935c ииииииииprintf("Enter IV (16 hex digits): ");
635c62 ииииииииfgets(buf, 99, stdin);
20cc35 ииииииииc = buf;
8f42cc ииииии}
f77471 ииииииif (unhex(ctx.plaintextXorMask, c, 8))
906bc1 ииииииииEXIT_ERR("Invalid IV. (Must be 16 hex digits.)");

e26fe7 ииии}
30af5a
16b543 ииии/* Get ciphertext 0 */
8cf875 ииииif (argc > nextArg) {
b0d208 ииииииc = argv[nextArg++];
b86a79 ииии} else {
1c0a80 ииииииprintf("Enter ciphertext0 (16 hex digits): ");
c2ec56 ииииииfgets(buf, 99, stdin);

819eec ииииииc = buf;
636fe7 ииии}
d0f3c8 ииииif (unhex(ctx.ciphertext0, c, 8))
ab36df ииииииEXIT_ERR("Invalid ciphertext0. (Must be 16 hex digits.)");
c4af5a
83be07 ииии/* Get ciphertext 1 */
2df875 ииииif (argc > nextArg) {
7ad208 ииииииc = argv[nextArg++];
666a79 ииии} else {
a98349 ииииииprintf("Enter ciphertext1 (16 hex digits): ");
6cec56 ииииииfgets(buf, 99, stdin);
e69eec ииииииc = buf;
ee6fe7 ииии}
54dfef ииииif (unhex(ctx.ciphertext1, c, 8))
8bf3eb ииииииEXIT_ERR("Invalid ciphertext1. (Must be 16 hex digits.)");
82af5a
14b74c ииии/* Set ctx */
37b998 ииииmemset(ctx.plaintextVector, 0, sizeof(ctx.plaintextVector));
6634e6 ииииfor (i = 0; i < sizeof(asciiBytes); i++)
f7c77d ииииииctx.plaintextVector[asciiBytes[i]/8] |= (1 << (asciiBytes[i] % 8));
7609b5 ииииctx.plaintextByteMask = 0x00;
a84bfc ииииif (searchType == 'E') {
c97dd1 ииииииmemset(ctx.plaintextXorMask, 0, sizeof(ctx.plaintextXorMask));

bc0a6e ииииииctx.searchInfo = 16; иииииииии/* useCBC=0, extraXor=0, boardActiveEn=1 */
476a79 ииии} else {
60ba9b ииииии/* already set plaintextXorMask = IV */

6e1c50 ииииииctx.searchInfo = 17; иииииииии/* useCBC=1, extraXor=0, boardActiveEn=1 */
706fe7 ииии}
48df1c ии}
1baf5a
ec0b8e ии/**** INITALIZE PARAMETERS FOR BLAZE CHALLENGE ****/
9f238e ииif (searchType == 'B') {
6caf5a
207380 ииии/* Get ciphertext byte */
cbf875 ииииif (argc > nextArg) {
8fd208 ииииииc = argv[nextArg++];
266a79 ииии} else {
1db847 ииииииprintf("Enter ciphertext byte (2 hex digits): ");
cfec56 ииииииfgets(buf, 99, stdin);
899eec ииииииc = buf;
2c6fe7 ииии}
790aab ииииif (unhex(ctx.ciphertext0, c, 1))
bdc25b ииииииEXIT_ERR("Invalid ciphertext byte. (Must be 2 hex digits.)");
--32ca 00084fa6dd680020009 Page 4 of initsrch.c
e0af5a
ce0ca4 ииии/* Set all ciphertext0 and ciphertext1 bytes to the input byte */
3f0371 ииииfor (i = 0; i < 8; i++)
e93cde ииииииctx.ciphertext0[i] = ctx.ciphertext1[i] = ctx.ciphertext0[0];
1faf5a
c7b74c ииии/* Set ctx */
9fb998 ииииmemset(ctx.plaintextVector, 0, sizeof(ctx.plaintextVector));
8afeec ииииctx.plaintextVector[0] = 1; иииииииииииииииии/* halt on 00000000???????? */
8805d2 ииииctx.plaintextByteMask = 0x0F; иииииииииииииии/* halt on 00000000???????? */
ce175f ииииmemset(ctx.plaintextXorMask, 0, sizeof(ctx.plaintextXorMask));
73be5d ииииctx.searchInfo = 2+16; иииииииии/* useCBC=0, extraXor=1, boardActiveEn=1 */
91df1c ии}
a2af5a
fd55a2 ии/**** INITALIZE PARAMETERS FOR MANUAL MODE ****/
dc1e07 ииif (searchType == 'M') {
34af5a
cca678 ииии/* Get plaintextVector */
21f875 ииииif (argc > nextArg) {
edd208 ииииииc = argv[nextArg++];
9a6a79 ииии} else {
ef6b16 ииииииprintf("The plaintextVector specifies which bytes can appear in the\n");
a9a298 ииииииprintf("plaintext. иThe MSB (of the first byte entered) specifies\n");
802647 ииииииprintf("whether 0xFF (255) can appear. The LSB is for 0x00.\n\n");
78b24d ииииииprintf("Enter plaintextVector (64 hex digits): ");
27ec56 ииииииfgets(buf, 99, stdin);
899eec ииииииc = buf;
a36fe7 ииии}
61e75f ииииif (unhex(ctx.plaintextVector, c, 32))
e70a17 ииииииEXIT_ERR("Invalid plaintextVector. (Must be 64 hex digits.)");
e0af5a
296737 ииии/* Get plaintextXorMask */
84f875 ииииif (argc > nextArg) {
36d208 ииииииc = argv[nextArg++];
aa6a79 ииии} else {
84b7f3 ииииииprintf("The plaintextXorMask is used for the CBC mode IV.\n");
122794 ииииииprintf("Enter plaintextXorMask (16 hex digits or ENTER=none): ");
98ec56 ииииииfgets(buf, 99, stdin);

6b6ee8 ииииииif (buf[0] == '\0');
d39be8 ииииииииstrcpy(buf, "0000000000000000");
dc9eec ииииииc = buf;
e96fe7 ииии}
64dd72 ииииif (unhex(ctx.plaintextXorMask, c, 8))
9fcece ииииииEXIT_ERR("Invalid plaintextXorMask. (Must be 16 hex digits.)");
b1af5a
fcb543 ииии/* Get ciphertext 0 */
9df875 ииииif (argc > nextArg) {
29d208 ииииииc = argv[nextArg++];
146a79 ииии} else {
f00a80 ииииииprintf("Enter ciphertext0 (16 hex digits): ");
efec56 ииииииfgets(buf, 99, stdin);
ab9eec ииииииc = buf;
5d6fe7 ииии}
19f3c8 ииииif (unhex(ctx.ciphertext0, c, 8))
b436df ииииииEXIT_ERR("Invalid ciphertext0. (Must be 16 hex digits.)");
a7af5a
afbe07 ииии/* Get ciphertext 1 */
5ff875 ииииif (argc > nextArg) {
cdd208 ииииииc = argv[nextArg++];
9d6a79 ииии} else {
918349 ииииииprintf("Enter ciphertext1 (16 hex digits): ");
adec56 ииииииfgets(buf, 99, stdin);
799eec ииииииc = buf;
f26fe7 ииии}
cddfef ииииif (unhex(ctx.ciphertext1, c, 8))
5ef3eb ииииииEXIT_ERR("Invalid ciphertext1. (Must be 16 hex digits.)");
d6af5a
67f875 ииииif (argc > nextArg) {
b3d208 ииииииc = argv[nextArg++];
d06a79 ииии} else {
ac9ea5 ииииииprintf("The plaintextByteMask specifies which bytes of the plaintext\n");
ea0847 ииииииprintf("are examined in the output. иNormally this is zero, but if\n");
84a104 ииииииprintf("only partial plaintext is available, the unknown bits can\n");
--7835 00008e1996880020009 Page 5 of initsrch.c
e2a994 ииииииprintf("be set to 1. For example, if the left-hand plaintext byte\n");

0c1884 ииииииprintf("is unknown, the mask would be 0x80.\n\n");
35f4f5 ииииииprintf("Enter plaintextByteMask (1 byte): ");
9fec56 ииииииfgets(buf, 99, stdin);
e59eec ииииииc = buf;
5c6fe7 ииии}
11d9bc ииииif (unhex(&(ctx.plaintextByteMask), c, 1))
0603d8 ииииииEXIT_ERR("Invalid plaintextByteMask. (Must be 2 hex digits.)");
d1af5a
9cf875 ииииif (argc > nextArg) {
a3d208 ииииииc = argv[nextArg++];
c46a79 ииии} else {
60efb7 ииииииprintf("\n\nThe searchInfo byte has two search parameters:\n");
58f304 ииииииprintf(" иbit 0x10: boardActiveEnable. иSet this to one.\n");
6137c1 ииииииprintf(" иbit 0x02: extraXor. иIf set, after the decryption is done,\n");


6555ba ииииииprintf(" ииииииииииииииииthe right half is XORed onto the left.\n");
2b6a7f ииииииprintf(" ииииииииииииииииThis is for Matt Blaze's challenge.\n");
7931e2 ииииииprintf(" иbit 0x01: useCBC. иIf set, the first ciphertext is XORed\n");
1779e1 ииииииprintf(" ииииииииииииииииonto the second plaintext before the second\n");
7a8401 ииииииprintf(" ииииииииииииииииplaintext is checked against the ");
c4a056 ииииииprintf( иииииииииииииииии"plaintextVector.\n(Higher bits control");
5295d9 ииииииprintf(" searchActive, which is currently unused.)\n");
41f125 ииииииprintf("\nEnter searchInfo (1 byte): ");
6eec56 ииииииfgets(buf, 99, stdin);
859eec ииииииc = buf;
a16fe7 ииии}
a7ac03 ииииif (unhex(&(ctx.searchInfo), c, 1))
196157 ииииииEXIT_ERR("Invalid searchInfo. (Must be 2 hex digits.)");
a5df1c ии}
42af5a
c7361b ииprintf("\n\n\n------------------------------ SEARCH PARAMETERS ");
630dc6 ииprintf("------------------------------\n");
ef6965 ииdumpBin(" иptxtVector = ", ctx.plaintextVector, 32);
22cb15 ииdumpBin(" ptxtXorMask = ", ctx.plaintextXorMask, 8);
dcbce6 ииdumpBin(" ciphertext0 = ", ctx.ciphertext0, 8);
51ed2d ииdumpBin(" ciphertext1 = ", ctx.ciphertext1, 8);
48fb0f ииdumpBin("ptxtByteMask = ", &(ctx.plaintextByteMask), 1);
8fe310 ииdumpBin(" иsearchInfo = ", &(ctx.searchInfo), 1);
54a225 ииprintf("--------------------------------------------");
90f41b ииprintf("-----------------------------------\n");
dfaf5a
022e67 ии/**** WRITE SEARCH PARAMETERS TO OUTPUT FILE ****/
fbeb50 ииprintf("\n\nWriting output file...");
14b77b ииfflush(stdout);
1a530e ииWriteSearchContext(outfile, &ctx);
1e55cf ииfclose(outfile);
46b812 ииprintf("Done.\n");
2bc86a ииreturn (0);
faefe6 }
76af5a
03af5a
5e38e5 /*
915ba9 и* иPrint a descriptive string followed by a binary value (in hex)
4c495d и*/
15e54b static void dumpBin(char *intro, unsigned char *data, int len) {
1d17e0 ииint i;
313b28 ииprintf(intro);
91c199 ииfor (i=len-1; i >= 0; i--)
1bcd57 ииииprintf("%02X", data[i]);
79fee8 ииprintf("\n");
c8efe6 }
c5af5a
2daf5a
9f38e5 /*


9cf0ab и* иConvert an ASCII digit from hex to an int, or return -1 if not hex.
09495d и*/
a55514 static int unhexDigit(char c) {
4253c4 ииif (c >= '0' && c <= '9')
cb03d6 ииииreturn (c - '0');
db8db1 ииif (c >= 'a' && c <= 'f')
b20ada ииииreturn (c - 'a' + 10);
0849e3 ииif (c >= 'A' && c <= 'F')
--2b51 001fdd8d50d80020009 Page 6 of initsrch.c
0da66f ииииreturn (c - 'A' + 10);
59a5eb ииreturn (-1); ииииииииииииииииииииииии/* return -1 for error: bad hex digit */
fdefe6 }
1caf5a
5eaf5a
2238e5 /*
1d22f5 и* иConvert a string of hex characters into unsigned chars.
a4495d и*/
62afe2 static int unhex(unsigned char *data, char *hex, int byteCount) {
01e13a ииint i,j;
6aaf5a
e6aea1 ииif (data == NULL || hex == NULL)
128f8d ииииreturn(-1);
afaf5a
852a60 ии/* Remove comments and whitespace */
97d4c3 ииfor (i=j=0; hex[i] != 0 && hex[i] != '%' && hex[i] != '#'; i++)
f701aa ииииif (hex[i] > ' ')
7c72f3 ииииииhex[j++] = hex[i];

3bf89c ииhex[j] = '\0';
a1af5a
665c18 ииif ((int)strlen(hex) != byteCount*2)
a3400d ииииreturn (-1);
e2ed9d ииmemset(data, 0, byteCount);
759629 ииfor (i = 0; i < 2*byteCount; i++) {
36eb9c ииииj = unhexDigit(hex[i]);
6e001d ииииif (j < 0)
47b9b9 ииииииreturn (-1);
bc5824 ииииdata[byteCount - 1 - i/2] |= j << ((i & 1) ? 0 : 4);
66df1c ии}
171eb2 ииfor (i = 2*byteCount; i < (int)strlen(hex); i++)
9e21eb ииииif (!isspace(hex[i]))
1cb9b9 ииииииreturn (-1);
23c86a ииreturn (0);
f8efe6 }
fcaf5a
baaf5a
fdaf5a
--c219 0008a71b2228002000a Page 1 of keyblock.c
8d2d03 /*****************************************************************************
535ef1 и* keyblock.c иииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииии*
33ec57 и* иииииииииииииKey Block & Search Context Management Functions иииииииииииии*
1c29eb и* ииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииии*
bf09fc и* иииWritten 1998 by Cryptography Research (http://www.cryptography.com) иии*
d58aaf и* ииииииand Paul Kocher for the Electronic Frontier Foundation (EFF). ииииии*
36caeb и* ииииииPlaced in the public domain by Cryptography Research and EFF. ииииии*
394992 и* иTHIS IS UNSUPPORTED FREE SOFTWARE. USE AND DISTRIBUTE AT YOUR OWN RISK. и*
c629eb и* ииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииии*
11c755 и* иIMPORTANT: U.S. LAW MAY REGULATE THE USE AND/OR EXPORT OF THIS PROGRAM. и*
1b29eb и* ииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииии*
27489b и*****************************************************************************
ee29eb и* ииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииии*
a46eef и* ииREVISION HISTORY: ииииииииииииииииииииииииииииииииииииииииииииииииииииии*
3129eb и* ииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииии*
0b28d9 и* ииVersion 1.0: иInitial release by Cryptography Research to EFF. иииииииии*
4929eb и* ииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииии*
b5d8c3 и*****************************************************************************/
60af5a
56feb2 #include <stdio.h>
a1bea3 #include <stdlib.h>
9b1465 #include <conio.h>
76324c #include <string.h>
e1c737 #include <memory.h>
0f0a8b #include <time.h>
88b1cb #include <ctype.h>
28c94c #include "search.h"
f92ba0 #include "keyblock.h"
b6af5a
817f4a static const char fileHeader[] = "This is a binary file containing the "
a9dcbc ииииииии"parameters for a DES search followed by 2^24 bits "
1a7150 ииииииии"indicating which regions of keyspace are left to search.\n\032";
e8af5a
1d4171 #define CTX_FILE_KEYBLOCKS_OFFSET (sizeof(fileHeader) + 58)

1391d3 #define MAX_KEY_REGION (1L<<24) иииииииии/* 2^56 keys / 2^32 keys per region */
b8708e static void EXIT_ERR(char *s) { fprintf(stderr, s); exit(1); }
cfaf5a
839edf static void WriteParams(FILE *fp, SEARCH_CTX *ctx);
9000a6 static void ReadParams(FILE *fp, SEARCH_CTX *ctx);
2baf5a
82af5a
3938e5 /*
bda837 и* иCreate a new search context file from a SEARCH_CTX structure
54495d и*/
f504e1 void WriteSearchContext(FILE *fp, SEARCH_CTX *ctx) {
91e4cc ииunsigned char temp[1024/8];
5cac42 ииlong i;
7faf5a
d261e8 ииfwrite(fileHeader, 1, sizeof(fileHeader), fp);
0e7f45 ииWriteParams(fp, ctx);
893148 ииmemset(temp, 255, 1024/8);
64052f ииfor (i = 0; i < MAX_KEY_REGION/1024; i++)
21d22a ииииfwrite(temp, 1, sizeof(temp), fp);
beefe6 }
73af5a
e0af5a
2c38e5 /*
f292e2 и* иRead search params from a FILE_STRUCTURE and get ready for
c0cc06 и* иииcalls to ReserveKeyRegion and FinishKeyRegion.
e0495d и*/
4ab92d void OpenSearchContext(FILE *fp, SEARCH_CTX *ctx) {
70180e ииlong blocksLeft, n;
ca17e0 ииint i;
60649a ииint c;
fdaf5a
da1d80 ииrewind(fp);
ae0183 ииfor (i = 0; i < sizeof(fileHeader); i++)
489aee ииииif (fgetc(fp) != fileHeader[i])
7c9d45 ииииииEXIT_ERR("Bad file header in search context file.\n");
42af5a
e43738 ииReadParams(fp, ctx);
8a2eda ииif (ftell(fp) != CTX_FILE_KEYBLOCKS_OFFSET)
--e4bf 00087902e818002000a Page 2 of keyblock.c
5346c8 ииииEXIT_ERR("Internal error: File length mismatch.");
52af5a
43a1af ии/* INITIALIZE THE SEARCH PROCESS PARAMETERS (except for totalUnits) */
3f0522 ииctx->nextUnstartedKeyBlock = 0;
30dd9c ииctx->totalFinishedKeyBlocks = 0;
7b09e5 ииctx->totalUnstartedKeyBlocks = MAX_KEY_REGION;
36d36a ииctx->totalPendingKeyBlocks = 0;
c7af5a
9cc760 ии/* FIND OUT HOW MANY KEY BLOCKS ARE LEFT */
e65f7b ииblocksLeft = 0;
0e785b ииfor (n = 0; n < MAX_KEY_REGION/8; n++) {
4dee98 ииииc = fgetc(fp);
6c373b ииииif (c < 0 || c > 255)
0ba78e ииииииEXIT_ERR("Error or premature EOF reading search context file.\n");
2ab9b9 ииииblocksLeft += (c&128)/128 + (c&64)/64 + (c&32)/32 + (c&16)/16 +
e1804b иииииииииии(c&8)/8 + (c&4)/4 + (c&2)/2 + (c&1);
4bdf1c ии}
9f5ea0 ииctx->totalUnstartedKeyBlocks = blocksLeft;
ad7c26 ииctx->totalFinishedKeyBlocks = иMAX_KEY_REGION - blocksLeft;
4defe6 }
76af5a
0aaf5a
f038e5 /*
853511 и* иReserve a key region to search. иWhen done searching it, the program
5b54f7 и* иshould call FinishKeyRegion. иThis function hands out blocks sequentially,
460a86 и* иstarting with the first unsearched one in the file context file.
6a448b и* иIf all blocks have been allocated and no free ones are left, the
424769 и* иfunction returns (-1).
9c495d и*/
f9dcfa long ReserveKeyRegion(FILE *fp, SEARCH_CTX *ctx) {
5c6b50 ииint c,b;
43af5a
8242e7 ииif (ctx->nextUnstartedKeyBlock >= MAX_KEY_REGION)
e48f8d ииииreturn(-1);
d63ef3 ииif (fseek(fp, CTX_FILE_KEYBLOCKS_OFFSET + ctx->nextUnstartedKeyBlock/8,

f96018 ииииииииииSEEK_SET))
276a9d ииииEXIT_ERR("Error seeking search context file.\n");
22b482 ииif ((ctx->nextUnstartedKeyBlock & 7) != 0)
1bee98 ииииc = fgetc(fp);
a7c101 ииwhile (ctx->nextUnstartedKeyBlock < MAX_KEY_REGION) {
f208b3 ииииb = (int)(ctx->nextUnstartedKeyBlock & 7);
e956ec ииииif (b == 0)
40d9d8 ииииииc = fgetc(fp);
9a373b ииииif (c < 0 || c > 255)
df563d ииииииEXIT_ERR("Error reading from search context file.\n");
d20bfd ииииif (b == 0 && c == 0) {
e49e77 ииииииctx->nextUnstartedKeyBlock += 8;
d85f6a ииииииcontinue;
7e6fe7 ииии}
7e9622 ииииif ((c << b) & 128)
5d88e1 ииииииbreak;
7cac89 ииииctx->nextUnstartedKeyBlock++;
d5df1c ии}
7042e7 ииif (ctx->nextUnstartedKeyBlock >= MAX_KEY_REGION)
2d400d ииииreturn (-1);
204784 ииctx->totalUnstartedKeyBlocks--;
30b7db ииctx->totalPendingKeyBlocks++;
e6b95c ииreturn (ctx->nextUnstartedKeyBlock++);
daefe6 }
caaf5a
adaf5a
1e38e5 /*
450ed1 и* иFinish searching a key region by marking it as completed in the contetx
156197 и* иfile.
33495d и*/
d1a6a3 void FinishKeyRegion(FILE *fp, SEARCH_CTX *ctx, long keyRegion) {
3e6b50 ииint c,b;
74af5a
04227a ииif (keyRegion < 0 || keyRegion > MAX_KEY_REGION)
859a72 ииииEXIT_ERR("Bad key region\n");
4a7978 ииif (fseek(fp, CTX_FILE_KEYBLOCKS_OFFSET + keyRegion/8, SEEK_SET))
8799f2 ииииEXIT_ERR("Error seeking in search context file.\n");
--82de 001f9fbc7698002000a Page 3 of keyblock.c
7d83b3 ииb = (int)(keyRegion & 7); ииииииииииииииииииииииииииииии/* b = bit in byte */
6a1425 ииc = getc(fp);
94e261 ииif (((c << b) & 128) == 0)
533188 ииииprintf("WARNING: FinishKeyRegion called, but region already searched!\n");
783a1e ииelse {
961464 ииииif (fseek(fp, CTX_FILE_KEYBLOCKS_OFFSET + keyRegion/8, SEEK_SET))
bd410b ииииииEXIT_ERR("Error seeking in search context file.\n");
010fe7 ииииfputc(c & (255 ^ (128>>b)), fp);
f78f5b ииииfflush(fp);
1af525 ииииctx->totalFinishedKeyBlocks++;
a8f539 ииииctx->totalPendingKeyBlocks--;
ccdf1c ии}
4fefe6 }
ddaf5a
53af5a
c438e5 /*
bcf380 и* иWrite a SEARCH_CTX structure to a FILE*
c1495d и*/
54c491 static void WriteParams(FILE *fp, SEARCH_CTX *ctx) {
303c52 ииfwrite(ctx->plaintextVector, 1, 32, fp); ииииииииииииииииииииии/* 32 bytes */
c78ca6 ииfwrite(ctx->plaintextXorMask, 1, 8, fp); ииииииииииииииииииииии/* и8 bytes */
f37a57 ииfwrite(ctx->ciphertext0, 1, 8, fp); иииииииииииииииииииииииииии/* и8 bytes */
473db4 ииfwrite(ctx->ciphertext1, 1, 8, fp); иииииииииииииииииииииииииии/* и8 bytes */
9945d9 ииfwrite(&(ctx->plaintextByteMask), 1, 1, fp); ииииииииииииииииии/* и1 byte и*/
64247e ииfwrite(&(ctx->searchInfo), 1, 1, fp); иииииииииииииииииииииииии/* и1 byte и*/
daefe6 }
60af5a
8038e5 /*
6fc898 и* иRead a SEARCH_CTX structure from a FILE*
e7495d и*/
782a49 static void ReadParams(FILE *fp, SEARCH_CTX *ctx) {
3f5e7e ииfread(ctx->plaintextVector, 1, 32, fp); иииииииииииииииииииииии/* 32 bytes */
868b1a ииfread(ctx->plaintextXorMask, 1, 8, fp); иииииииииииииииииииииии/* и8 bytes */
fb6dea ииfread(ctx->ciphertext0, 1, 8, fp); ииииииииииииииииииииииииииии/* и8 bytes */
7fb838 ииfread(ctx->ciphertext1, 1, 8, fp); ииииииииииииииииииииииииииии/* и8 bytes */
c6f5b4 ииfread(&(ctx->plaintextByteMask), 1, 1, fp); иииииииииииииииииии/* и1 byte и*/
942460 ииfread(&(ctx->searchInfo), 1, 1, fp); ииииииииииииииииииииииииии/* и1 byte и*/
42efe6 }
f9af5a
--c618 001257315318002000b Page 1 of keyblock.h
8d2d03 /*****************************************************************************
aea835 и* keyblock.h иииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииии*
d8ed67 и* иииииииииииииииииииииииHeader file for keyblock.c ииииииииииииииииииииииии*
ed29eb и* ииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииии*
0209fc и* иииWritten 1998 by Cryptography Research (http://www.cryptography.com) иии*
4f8aaf и* ииииииand Paul Kocher for the Electronic Frontier Foundation (EFF). ииииии*
abcaeb и* ииииииPlaced in the public domain by Cryptography Research and EFF. ииииии*
9f4992 и* иTHIS IS UNSUPPORTED FREE SOFTWARE. USE AND DISTRIBUTE AT YOUR OWN RISK. и*
e829eb и* ииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииии*
94c755 и* иIMPORTANT: U.S. LAW MAY REGULATE THE USE AND/OR EXPORT OF THIS PROGRAM. и*
a329eb и* ииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииии*
73489b и*****************************************************************************
0d29eb и* ииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииии*
866eef и* ииREVISION HISTORY: ииииииииииииииииииииииииииииииииииииииииииииииииииииии*
bd29eb и* ииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииии*
5128d9 и* ииVersion 1.0: иInitial release by Cryptography Research to EFF. иииииииии*
8e29eb и* ииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииии*
93d8c3 и*****************************************************************************/
44af5a
00c374 #ifndef __KEYBLOCK_H
1f33ca #define __KEYBLOCK_H
0caf5a
334d26 void WriteSearchContext(FILE *fp, SEARCH_CTX *sp);
55d541 void OpenSearchContext(FILE *fp, SEARCH_CTX *ctx);
ae3447 long ReserveKeyRegion(FILE *fp, SEARCH_CTX *ctx);
93a2ae void FinishKeyRegion(FILE *fp, SEARCH_CTX *ctx, long keyRegion);
75af5a
1c7454 #endif
25af5a
--5629 0005fb2aed48002000c Page 1 of search.c
8d2d03 /*****************************************************************************
e284a4 и* search.c иииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииии*
8540b6 и* ииииииииииииииииииииSearch Engine Controller Program иииииииииииииииииииии*
2629eb и* ииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииии*
8109fc и* иииWritten 1998 by Cryptography Research (http://www.cryptography.com) иии*
728aaf и* ииииииand Paul Kocher for the Electronic Frontier Foundation (EFF). ииииии*
64caeb и* ииииииPlaced in the public domain by Cryptography Research and EFF. ииииии*
204992 и* иTHIS IS UNSUPPORTED FREE SOFTWARE. USE AND DISTRIBUTE AT YOUR OWN RISK. и*
9329eb и* ииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииии*
b7c755 и* иIMPORTANT: U.S. LAW MAY REGULATE THE USE AND/OR EXPORT OF THIS PROGRAM. и*
a029eb и* ииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииии*
5c489b и*****************************************************************************
5d29eb и* ииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииии*
e46eef и* ииREVISION HISTORY: ииииииииииииииииииииииииииииииииииииииииииииииииииииии*
b629eb и* ииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииии*
9028d9 и* ииVersion 1.0: иInitial release by Cryptography Research to EFF. иииииииии*
9629eb и* ииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииии*
f9d8c3 и*****************************************************************************/
6eaf5a
d4bcd3 #define SOFTWARE_VERSION "1.0"
89a5c9 #define SOFTWARE_DATE иии"04-21-1998"
6baf5a
4baf5a
c9bea3 #include <stdlib.h>
70feb2 #include <stdio.h>
f9bb5f #include <assert.h>
06b1cb #include <ctype.h>
05c737 #include <memory.h>
200a8b #include <time.h>
48324c #include <string.h>
8a1465 #include <conio.h>
c1c94c #include "search.h"
601519 #include "chipio.h"
a12ba0 #include "keyblock.h"
ce2bac #include "des.h"
a1af5a
aaaf5a
3daf5a
a538e5 /*
0e1ae3 и* иSEARCH_CHIP STRUCTURE: Contains status information about each chip.
78775e и*
d2e2cf и* иииboard: иThe board this chip is on (1 byte).
f79e01 и* иииchip: иThe ID of this chip on the board (1 byte).
057501 и* иииinitialized: и0=uninitialized, 1=initialized, -1=defective.
d66102 и* иииregion[]: Specifies the top 24 bits of the key being searched by each
3c7c40 и* иииииииsearch unit. A value of -1 means the search unit is idle
195c24 и* иииииии(idle), and a value of -2 means the search unit is not used.
ad77ae и* иииoverFlow[]: Specifies the value at which the low 32 bits of the
cd7f25 и* иииииииkey (the key counter) will have gone through all 2^32
cfc098 и* иииииииpossibilities. иNote: this only has the top 24 bits of the
3cb9dd и* иииииииcounter, which corresponds to key bytes: .. .. .. XX XX XX.. (LSB)
b10b92 и* иииlastSeen[]: иThe value last seen in the low 32 bits of the key.
5b33e4 и* иииииииThis has the same encoding as overFlow.
d3495d и*/
92f9cb typedef struct CHIP_CTX {
7c2fe6 ииunsigned char board, chip;
4d3673 ииint initialized;
f01382 ииlong region[SEARCH_UNITS_PER_CHIP];
95dbbf ииlong overFlow[SEARCH_UNITS_PER_CHIP];
ceb33b ииlong lastDone[SEARCH_UNITS_PER_CHIP];
5861b7 ииstruct CHIP_CTX *nextChip;
feb846 } CHIP_CTX;
76af5a
38af5a
1238e5 /*
a225ec и* иGLOBAL VARIABLES
17495d и*/
2329db CHIP_CTX *CHIP_ARRAY = NULL;
f92415 SEARCH_CTX CTX;
4acb69 static int QUIET = 0;
08dcb4 static int VERBOSE = 0;
5f6c5f static FILE *FP_LOG = NULL;
--2313 0001e8485cc8002000c Page 2 of search.c
e0af5a
1aaf5a
9938e5 /*
aae9fc и* иFUNCTION PROTOTYPES & MINI FUNCTIONS & MACROS
2b495d и*/
54708e static void EXIT_ERR(char *s) { fprintf(stderr, s); exit(1); }
c2f311 long ReadConfig(char *configFilespec);
e0a2be void RunSearch(FILE *ctxFile);
b5e2b2 void InitializeChip(CHIP_CTX *cp, SEARCH_CTX *ctx);
0c49e0 void ServiceChip(CHIP_CTX *cp, SEARCH_CTX *ctx, FILE *ctxFile);
ee873d long GetUnitKeyCounter(int board, int chip, int unit);
ff0862 void CheckAndPrintKey(CHIP_CTX *cp, SEARCH_CTX *ctx, int unit);
5f8767 int ServiceKeyboard(SEARCH_CTX *ctx);
c078a5 int CheckKey(unsigned char key[56], SEARCH_CTX *ctx);
52af5a
64af5a
8538e5 /*
ee2faa и* иReadConfig(): иRead the search array configuration file. иThis file
9198e6 и* иииииspecifies the I/O base port for SetBaseAddress and also the
643bd0 и* иииииsearch units. иIt can contain 3 kinds of lines: comments that
a271b3 и* иииииthat with '%', base port with "PORT=210" for port 210 hex, and

a1849f и* иииии"UNIT= 12 32 8" to add a search unit on board 0x12, chip 0x32,
b97255 и* иииииand unit 0x08 (all hex). иThe function constructs CHIP_ARRAY
0ac94c и* иииииas a linked list of chips.
0daf98 и* ииReturns: Total number of search units.
a0495d и*/
54eb8e long ReadConfig(char *configFilespec) {
79bc33 ииchar buffer[200];
a58685 ииint basePort = -1;
ae08f4 ииint board, chip, unit, i;
31e8aa ииint lastBoard = -1, lastChip = -1;
1ec31e ииlong totalUnits = 0;
c344bc ииCHIP_CTX *cp;
07b166 ииFILE *fp;
27af5a
a2d67e ииcp = CHIP_ARRAY;
398d09 ииif (cp != NULL)

6860b7 ииииEXIT_ERR("Chip array base isn't NULL. (Internal error.)\n");
7caf5a
c4a9d2 ииfp = fopen(configFilespec, "rb");
d2b291 ииif (fp == NULL)
668f5c ииииEXIT_ERR("Error opening configuration filespec.\n");
8caf5a
b994bf ииif (!QUIET) printf("Reading configuration file \"%s\".\n", configFilespec);
5a0a67 ииwhile (fgets (buffer, 190, fp) != NULL) {
342761 ииииif (buffer[0] == '\0' || buffer[0] == '%')
205f6a ииииииcontinue;
c04d2e ииииif (memcmp(buffer, "PORT=", 5) == 0) {
c1c6f2 ииииииbasePort = 0;
9f6771 ииииииsscanf(buffer+5, "%x", &basePort);
6ae67c ииииииif (basePort <= 0)
42a4e2 ииииииииEXIT_ERR("Defective PORT= in configuration file.\n");


b0b41f ииииииSetBaseAddress(basePort);
50f03a ииииииif (!QUIET) printf("Set base port to %x\n", basePort);
b4da88 ииииииif (FP_LOG && VERBOSE) fprintf(FP_LOG, "Set base port=0x%x\n", basePort);
296fe7 ииии}
25d89c ииииelse if (memcmp(buffer, "UNIT=", 5) == 0 ||
1c3b05 ииииииииииииmemcmp(buffer, "FAIL=", 5) == 0) {
3044d4 ииииииboard = chip = unit = -1;
0a1445 ииииииsscanf(buffer+5, "%x %x %x", &board, &chip, &unit);
ca5e35 ииииииif (board < 0 || chip < 0 || unit < 0)
f86669 ииииииииEXIT_ERR("Defective UNIT= or FAIL= in configuration file.\n");
8cae4c ииииииif (board < lastBoard || (board == lastBoard && chip < lastChip))
715fa0 ииииииииEXIT_ERR("Bad UNIT= or FAIL= in config: board & chip must decrease\n");
bf274a ииииииif (board != lastBoard || chip != lastChip) {
ca772c ииииииииlastBoard = board;
3343e1 ииииииииlastChip = chip;
807e0b ииииииииif (cp == NULL)
629822 ииииииииииcp = CHIP_ARRAY = malloc(sizeof(CHIP_CTX));
7905d7 ииииииииelse {
b656fb ииииииииииcp->nextChip = malloc(sizeof(CHIP_CTX));
1e2825 ииииииииииcp = cp->nextChip;
--4bd2 0003642e9df8002000c Page 3 of search.c
e67fb0 ииииииии}
e237f7 ииииииииcp->board = (unsigned char)board;

927f04 ииииииииcp->chip = (unsigned char)chip;
902174 ииииииииcp->initialized = 0;
b11ffd ииииииииfor (i = 0; i < SEARCH_UNITS_PER_CHIP; i++)
2068f5 ииииииииииcp->region[i] = -2;
48d968 ииииииииcp->nextChip = NULL;
a342cc ииииии}
a2fac6 ииииииif (cp->region[unit] == -2 && memcmp(buffer, "UNIT=", 5) == 0) {

1b9c12 ииииииииtotalUnits++;
cf72d7 ииииииииcp->region[unit] = -1; иииииииииииииииииии/* mark the unit as extant */
f442cc ииииии}
936a79 ииии} else {
d0f07c ииииииfprintf(stderr, "IGNORING UNKNOWN CONFIG FILE LINE: \"%s\"\n", buffer);
3c6fe7 ииии}
aadf1c ии}
56ed24 ииfclose(fp);
24f7ab ииif (CHIP_ARRAY == NULL)
ca50bd ииииEXIT_ERR("Error: Configuration file does not have any valid units.\n");

fbaf5a
ba291a ииif (FP_LOG && VERBOSE) {

0f24bf ииииfprintf(FP_LOG, "Configuration summary:\n");
7e5d63 ииииfor (cp = CHIP_ARRAY; cp != NULL; cp = cp->nextChip) {
4e1222 ииииииfor (i = 0; i < SEARCH_UNITS_PER_CHIP; i++)
f6f2e5 ииииииииif (cp->region[i] != -2)
debb16 ииииииииииfprintf(FP_LOG, "%s=0x%02X 0x%02X 0x%02X\n",
e33ccd ииииииииииииииииии(cp->initialized >= 0) ? "UNIT" : "FAIL",
bb9127 иииииииииииииииииииcp->board, cp->chip, i);
8d6fe7 ииии}
c4df1c ии}
19a980 ииif (!QUIET) printf("Config done: Found %ld search units.\n", totalUnits);
239057 ииif (FP_LOG) fprintf(FP_LOG, "Config found %ld search units.\n", totalUnits);
d43faf ииreturn (totalUnits);
15efe6 }
0eaf5a
d8af5a
0caf5a
fe79bf void main(int argc, char **argv) {
c1e020 ииFILE *ctxFile;
e417e0 ииint i;
19e624 ииtime_t t;
f944bc ииCHIP_CTX *cp;
63af5a
7207b6 ииprintf("\nDES Search Engine Controller (Ver %s, %s). May be export "
a2ffaa иииииииии"controlled.\nWritten 1998 by Cryptography Research "
142e08 иииииииии"(http://www.cryptography.com) for EFF.\n"
2dc4fd иииииииии"This is unsupported "
7b1151 иииииииии"free software: Use and distribute at your own risk.\n"
b0805d иииииииии"-------------------------------------------"
3b04bf иииииииии"---------------------------------\n\n\n",
44a1fb иииииииииSOFTWARE_VERSION, SOFTWARE_DATE);
daba53 ииif (argc < 3) {
cfed02 ииииfprintf(stderr,
18f2f1 иииииииии"Usage: иsearch configFile contextFile [logfile] [-v] [-q]\n"
da327c иииииииии" ииииconfigFile: Search array configuration from autoconf\n"
398e60 иииииииии" иииcontextFile: Search context (from init)\n"
ddf370 иииииииии" иииииииlogfile: Output file with detailed reporting info\n"
fd94cd иииииииии" ииииииииииии-v: verbose output to logfile\n"
578e57 иииииииии" ииииииииииии-q: quiet mode (less output to the screen)\n"
e1a553 иииииииии" и(Note: paramaters must be in the order above.)\n");
6b646c ииииexit(1);
f5df1c ии}
0a5434 ииfor (i = 3; i < argc; i++) {
05d081 ииииif (i == 3 && argv[i][0] != '-') {
df3904 ииииииFP_LOG = fopen(argv[3], "w");
a1dd6b ииииииif (FP_LOG == NULL)
8bc2fe ииииииииEXIT_ERR("Error opening log file.");
2e14ab ииии} else if (stricmp(argv[i], "-v") == 0)
e593ab ииииииVERBOSE = 1;
fe4009 ииииelse if (stricmp(argv[i], "-q") == 0)
8b9a4c ииииииQUIET = 1;
3683c8 ииииelse {
--1911 000b393ee878002000c Page 4 of search.c
5e813f ииииииfprintf(stderr, "Unknown parameter \"%s\"\n", argv[i]);

e6c1d2 ииииииexit(1);
cc6fe7 ииии}
5edf1c ии}
b0af5a
9f305a ии/* READ CONFIGURATION FILE SPECIFYING BASE PORT AND SEARCH UNITS */
5dff7c ииCTX.totalUnits = ReadConfig(argv[1]);
13af5a
76735d ии/* RESET THE SEARCH ARRAY */
861d2e ииif (!QUIET) printf("Resetting the search array.\n");
c4969d ииi = -1;
7e859a ииfor (cp = CHIP_ARRAY; cp != NULL; cp = cp->nextChip) {
e607b1 ииииif (i != cp->board) {
06ae60 ииииииi = cp->board;
7b7546 ииииииResetBoard(i);
056fe7 ииии}
99df1c ии}
71ec6b ииt = time(NULL);
94af5a
3da542 ии/* READ SEARCH FILE SPECIFYING SEARCH INFO & REMAINING KEY BLOCKS */
10ee15 ииctxFile = fopen(argv[2], "r+b");
20ff66 ииif (ctxFile == NULL) {
c0f8b7 ииииfprintf(stderr, "Error opening search context file \"%s\"\n", argv[2]);
4c646c ииииexit(1);
10df1c ии}
a9af5a
5d1da1 ии/* MAKE SURE RESET HAD AT LEAST 1 SECOND TO SETTLE. */
7ab357 ииif (!QUIET) printf("Waiting for reset to settle.\n");
4458f4 ииwhile(t + 1 >= time(NULL)) {}
30af5a
b65d7f ии/* RUN THE SEARCH! */
362733 ииRunSearch(ctxFile);
259966 ииfclose(ctxFile);
0f33d0 ииif (!QUIET) printf("Exiting.\n");
86efe6 }
cdaf5a
e1af5a
8538e5 /*
8f13e5 и* иRun the search. Uses the search parameters in the
ffec91 и* ииииииglobal linked list CHIP_ARRAY and keeps its context info
c140a5 и* ииииииin the global CTX.
7c495d и*/
2fb622 void RunSearch(FILE *ctxFile) {
2944bc ииCHIP_CTX *cp;
2d049e ииSEARCH_CTX *ctx = &CTX;
79c4fb ииint halt = 0;
d4ceca ииtime_t startTime, lastReportTime, t;
8cd6eb ииlong loopCount = 0;
95431e ииchar buffer[128];
c3af5a
c9fbd6 ииif (!QUIET) printf("Loading search context file...\n");
578e14 ииOpenSearchContext(ctxFile, ctx);
45af5a
da37ac ииprintf("Initialization Successful - Beginning search.\n");
09a530 ииif (QUIET) printf("Quiet mode: Press ? for help during search.\n");
7c2a59 ииif (FP_LOG && VERBOSE) fprintf(FP_LOG, "--- Beginning search ---\n");
46ec5d ииfor (cp = CHIP_ARRAY; cp != NULL; cp = cp->nextChip)
e4084a ииииInitializeChip(cp, ctx);
9abe63 ииstartTime = time(NULL);
155889 ииlastReportTime = 0;
1daf5a
b005cf ииwhile (halt == 0) {
5ffb77 ииииt = time(NULL); иииииииииииииииииииииииииииииии/* report every 5 seconds */
97eba6 ииииif (t/5 != lastReportTime/5) {
e24d90 ииииииsprintf(buffer, "%7ld blocks done, %7ld left, %4ld running (time=%7ld).",
c347d2 ииииииииииииииctx->totalFinishedKeyBlocks, ctx->totalUnstartedKeyBlocks +

16efa5 ииииииииииииииctx->totalPendingKeyBlocks, ctx->totalPendingKeyBlocks,
db00a9 ииииииииииииии(long)(t - startTime));
889596 ииииииif (!QUIET) printf(">%s ('?'=help)\n", buffer);
751c3a ииииииif (FP_LOG && VERBOSE) fprintf(FP_LOG, "Report: %s\n", buffer);
e61ab3 ииииииlastReportTime = t;
b36fe7 ииии}
--75c4 000ce8281be8002000c Page 5 of search.c
9d0eaa ииииfor (cp = CHIP_ARRAY; cp != NULL && halt == 0; cp = cp->nextChip) {

3f8447 ииииииServiceChip(cp, ctx, ctxFile);
f591f1 ииииииif (ServiceKeyboard(ctx) < 0)
e6cd41 ииииииииhalt = 1;
4a6fe7 ииии}
b2bd80 ииииif (ctx->totalFinishedKeyBlocks == (1L<<24))
16865f ииииииhalt = 1;
0b1f76 ииииGetRegister(255, 255, 255);
3b5ff2 ииииloopCount++;
43df1c ии}
08efe6 }
92af5a
c6af5a
4f38e5 /*
2da22e и* иInitializeChip(cp, ctx): иInitialize a chip whose chip context is
cdf2f7 и* иииииat cp, using the search parameters at ctx.
cf495d и*/

087c0e void InitializeChip(CHIP_CTX *cp, SEARCH_CTX *ctx) {
cfe13a ииint i,j;
abaf5a

3c3661 ииif (!QUIET) printf("Initializing board 0x%02X, chip 0x%02X\n",
a40940 ииииииииииcp->board, cp->chip);
faae75 ииif (FP_LOG && VERBOSE) fprintf(FP_LOG,
9c7828 ииииииииии"Initializing board 0x%02X, chip 0x%02X\n", cp->board, cp->chip);
be1207 ииSetRegister(cp->board, cp->chip, REG_PTXT_BYTE_MASK, 0xFF); ии/* halt chip */
0b339a ииfor (i = 0; i < 32; i++)
fbd055 ииииSetRegister(cp->board, cp->chip, REG_PTXT_VECTOR+i,
cbb8cc ииииииииииииctx->plaintextVector[i]);
131f76 ииfor (i = 0; i < 8; i++)
64eca4 ииииSetRegister(cp->board, cp->chip,REG_PTXT_XOR_MASK+i,
2689f7 ииииииииииииctx->plaintextXorMask[i]);
001f76 ииfor (i = 0; i < 8; i++)
f98081 ииииSetRegister(cp->board, cp->chip, REG_CIPHERTEXT0+i, ctx->ciphertext0[i]);
d21f76 ииfor (i = 0; i < 8; i++)
174d1c ииииSetRegister(cp->board, cp->chip, REG_CIPHERTEXT1+i, ctx->ciphertext1[i]);
ec1eef ииSetRegister(cp->board, cp->chip, REG_PTXT_BYTE_MASK, ctx->plaintextByteMask);
e20a1e ииSetRegister(cp->board, cp->chip, REG_SEARCHINFO, ctx->searchInfo);
0faf5a
70b777 ии/* TO BE SAFE, VERIFY THAT ALL REGISTERS WERE WRITTEN PROPERLY */
20f147 ии/* (Each chip only gets initialized once, so this is quick.) */
060b46 ииj = 0;
e6339a ииfor (i = 0; i < 32; i++)
f9b65f ииииj += CheckRegister(cp->board, cp->chip, REG_PTXT_VECTOR+i,
beb8cc ииииииииииииctx->plaintextVector[i]);
d18715 ииfor (i = 0; i < 8; i++) {
8fd1da ииииj += CheckRegister(cp->board, cp->chip, REG_PTXT_XOR_MASK+i,
9a89f7 ииииииииииииctx->plaintextXorMask[i]);


bb5fb5 ииииj += CheckRegister(cp->board, cp->chip, REG_CIPHERTEXT0+i,
610e6a ииииииииииииctx->ciphertext0[i]);
5854f1 ииииj += CheckRegister(cp->board, cp->chip, REG_CIPHERTEXT1+i,
5b91bf ииииииииииииctx->ciphertext1[i]);
7bdf1c ии}
1b77a6 ииj += CheckRegister(cp->board, cp->chip, REG_PTXT_BYTE_MASK,
483279 ииииииииииctx->plaintextByteMask);
e013d5 ииj += CheckRegister(cp->board, cp->chip, REG_SEARCHINFO, ctx->searchInfo);
23fed0 ииif (j != 0) {

c5e719 ииииprintf("Bad register on board 0x%02X, chip 0x%02X. Chip disabled.\n",
6ad6e1 ииииииииииииcp->board, cp->chip);
4e4342 ииииif (FP_LOG) fprintf(FP_LOG, "Bad register on board 0x%02X, chip 0x%02X.%s",
8960af ииииииииииииcp->board, cp->chip, " Chip disabled.\n");
dadf1c ии}
36af5a
e1791e ии/* UPDATE THE CHIP CONTEXT */
4ff396 ииcp->initialized = (j == 0) ? 1 : -1; ииииииииии/* initialized or defective */
b8efe6 }
79af5a
96af5a
c538e5 /*
a3cc9c и* иService a chip by doing the following:
274c8c и* иии- Check if it has halted
670a9d и* иии- Check to see if it has finished its region
ceb01a и* иии- Restart if it is idle
--040d 00045bb51768002000c Page 6 of search.c
47495d и*/
a30d32 void ServiceChip(CHIP_CTX *cp, SEARCH_CTX *ctx, FILE *ctxFile) {
05538a ииint unit;
5019fa ииlong k;
2aaf5a
348a5b ииif (cp->initialized < 0)
0f3471 ииииreturn;
25af5a
ec6000 ии/*
b65d45 иии* иREAD KEYS & RESTART ANY HALTED UNITS
adf9a6 иии*/
6700ef ииfor (unit = 0; unit < SEARCH_UNITS_PER_CHIP; unit++) {
ea5e8f ииииif (cp->region[unit] >= 0) { ииииииииииииииииииии/* if currently running */
2bca7c ииииииif (!(GetRegister(cp->board, cp->chip, REG_SEARCH_STATUS(unit)) & 1)) {
29e540 ииииииииCheckAndPrintKey(cp, ctx, unit);
db6490 ииииииииSetRegister(cp->board, cp->chip, REG_SEARCH_STATUS(unit), 1);
1d42cc ииииии}
cd6fe7 ииии}
efdf1c ии}
23af5a
516000 ии/*
ae51e4 иии* иSee if any units have completed their search regions
ba3534 иии* иииNote: If I/O bandwidth was a problem and the clock rate of the
aa4028 иии* ииииииsearch system was fixed, we could predict when the keycounter
7c32c2 иии* ииииииwould flip and avoid this check.
9af9a6 иии*/
1600ef ииfor (unit = 0; unit < SEARCH_UNITS_PER_CHIP; unit++) {
fda2b3 ииииif (cp->region[unit] < 0)
b25f6a ииииииcontinue;
fcbaec ииииk = GetUnitKeyCounter(cp->board, cp->chip, unit);
637ad2 ииииk -= cp->overFlow[unit];
0c9fc8 ииииif (k < 0)
db5630 ииииииk += (1L << 24);
4c9bfb ииииif (VERBOSE && FP_LOG) fprintf(FP_LOG,
3d961d ииииииииииииии"Board 0x%02X chip 0x%02X unit 0x%02X is at 0x%06lX "
91fd7c ииииииииииииии"(lastDone=0x%06lX, overFlow=%06lX)\n",

a5a2d2 ииииииииииииииcp->board, cp->chip, unit, k,
02106a ииииииииииииииcp->lastDone[unit], cp->overFlow[unit]);

9a7e0d ииииif (k < cp->lastDone[unit]) {
eb7d4e ииииииif (!QUIET) printf("Board 0x%02X chip 0x%02X unit 0x%02X finished block "
9e7322 ииииииииииииии"0x%06lX (lastDone=0x%06lX, got 0x%06lX, overFlow=%06lX)\n",
394e24 ииииииииииииииcp->board, cp->chip, unit, cp->region[unit],

cc3197 ииииииииииииииcp->lastDone[unit], k, cp->overFlow[unit]);
64bdf0 ииииииif (FP_LOG) fprintf(FP_LOG, "Unit 0x%02X 0x%02X 0x%02X finished "
d455fb ииииииииииииии"0x%06lX (last=%06lX, got %06lX, oFlow=%06lX)\n",
284e24 ииииииииииииииcp->board, cp->chip, unit, cp->region[unit],


263197 ииииииииииииииcp->lastDone[unit], k, cp->overFlow[unit]);
c14588 ииииииFinishKeyRegion(ctxFile, ctx, cp->region[unit]); ииии/* region is done */
72c33f ииииииcp->region[unit] = -1; ииииииииииииииииииииииииииии/* unit is now idle */
ba6a79 ииии} else {
b01b8b ииииииcp->lastDone[unit] = k;
de6fe7 ииии}
3edf1c ии}
faaf5a
036000 ии/*
beae98 иии* иStart any units that are currently stalled
38f9a6 иии*/
0000ef ииfor (unit = 0; unit < SEARCH_UNITS_PER_CHIP; unit++) {
8faa03 ииииif (cp->region[unit] == -1) {
7cb961 ииииииk = ReserveKeyRegion(ctxFile, ctx);
f9cd11 ииииииif (k < 0)
b431a8 ииииииииbreak; ииииииииииииииииииииииииииииииииииииииии/* no more regions... */
35db12 ииииииif (!QUIET) printf("Starting board 0x%02X, chip 0x%02X, unit 0x%02X... ",
3fe31b иииииииииииcp->board, cp->chip, unit);

bd2b54 ииииииif (FP_LOG) fprintf(FP_LOG, "Starting unit 0x%02X 0x%02X 0x%02X... ",
e8e31b иииииииииииcp->board, cp->chip, unit);
d148cb ииииииcp->region[unit] = k;
8faf5a
7523f8 ииииии/* LOAD UP THE KEY REGION AND LET 'ER RIP... */
49945b ииииииSetRegister(cp->board, cp->chip, REG_SEARCH_KEY(unit)+6,
6aad2b ииииииииииииии(unsigned char)((k >> 16) & 0xFF));
457b3f ииииииSetRegister(cp->board, cp->chip, REG_SEARCH_KEY(unit)+5,
--721d 0002227a35d8002000c Page 7 of search.c
99606b ииииииииииииии(unsigned char)((k >> 8) & 0xFF));
4021e3 ииииииSetRegister(cp->board, cp->chip, REG_SEARCH_KEY(unit)+4,
593bf5 ииииииииииииии(unsigned char)(k & 0xFF));
d50d06 ииииииSetRegister(cp->board, cp->chip, REG_SEARCH_KEY(unit)+3, 0);
6a92d3 ииииииSetRegister(cp->board, cp->chip, REG_SEARCH_KEY(unit)+2, 0);
353abd ииииииSetRegister(cp->board, cp->chip, REG_SEARCH_KEY(unit)+1, 0);
37a568 ииииииSetRegister(cp->board, cp->chip, REG_SEARCH_KEY(unit)+0, 0);
f2af5a
176841 ииииииSetRegister(cp->board, cp->chip, REG_SEARCH_STATUS(unit), 1); ии/* GO! */
08af5a
d3fd1a ииииии/* READ OUT THE KEY COUNTER (3 BYTES) FOR OVERFLOW SENSING */
b20f12 ииииииk = GetUnitKeyCounter(cp->board, cp->chip, unit);
619957 ииииииcp->overFlow[unit] = k;
881b8b ииииииcp->lastDone[unit] = k;
282f76 ииииииif (!QUIET) printf("Region=0x%06lX, overFlow=0x%06lX\n",
f3eb34 ииииииииииииcp->region[unit], k);
0ac312 ииииииif (FP_LOG) fprintf(FP_LOG, "Region=0x%06lX, overFlow=0x%06lX\n",
77eb34 ииииииииииииcp->region[unit], k);
5a6fe7 ииии}
90df1c ии}
97efe6 }
38af5a
21af5a
e338e5 /*
a964e4 и* иRead the value of a rapidly-incrementing key counter register.
58278f и* ииииThe function reads the register twice, finds the most-significant
5e7253 и* ииииbit that changed during the operation, and returns the later
b24a30 и* ииии(higher) value with all bits to the right of the one that changed
224233 и* ииииset to zero.
d494e7 и* иThe return value is the top 24 bits of the low 32 bits of the
2740a3 и* ииииkey counter -- i.e., key bytes (MSB).. .. .. XX XX XX ..(LSB)

57495d и*/
5a0094 long GetUnitKeyCounter(int board, int chip, int unit) {
559ab5 ииlong v1, v2, m;
31565f ииdo {
76f04f ииииv1 = ((long)GetRegister(board, chip, REG_SEARCH_KEY(unit)+3)) << 16;
0b190c ииииv1 |= ((long)GetRegister(board, chip, REG_SEARCH_KEY(unit)+2)) << 8;
56d778 ииииv1 |= ((long)GetRegister(board, chip, REG_SEARCH_KEY(unit)+1));
9bb868 ииииv2 = ((long)GetRegister(board, chip, REG_SEARCH_KEY(unit)+3)) << 16;
9a512b ииииv2 |= ((long)GetRegister(board, chip, REG_SEARCH_KEY(unit)+2)) << 8;
996273 ииииv2 |= ((long)GetRegister(board, chip, REG_SEARCH_KEY(unit)+1));

184051 ии} while (v1 > v2);
f9fc72 ииfor (m = 0x800000L; m != 0; m >>= 1) {
63e73f ииииif ((v1 & m) != (v2 & m)) {
9012d1 ииииииv2 = (v2 & (0xFFFFFFL - m + 1));
6688e1 ииииииbreak;
696fe7 ииии}
99df1c ии}
aa0597 ииreturn (v2);
2aefe6 }
6daf5a
00af5a
b238e5 /*
8e23dc и* иGet the key out of a halted unit and print it to the screen/logs
d0495d и*/
5caa69 void CheckAndPrintKey(CHIP_CTX *cp, SEARCH_CTX *ctx, int unit) {
8a5ec8 ииunsigned char key[7];
4c4fa7 ииunsigned char binKey[56];
bcd5f5 ииchar buf[128];
0c193c ииint i,j, goodKey;
e1af5a
73aec4 ииfor (i = 0; i < 7; i++)

615cd8 ииииkey[i] = (unsigned char)GetRegister(cp->board, cp->chip,
ebdf14 ииииииииииииREG_SEARCH_KEY(unit)+i);
1e8cfc ииif (--(key[0]) == 0xFF) ииииииииииииииииииииииииииииииииии/* Decrement key */
804d72 ииииif (--(key[1]) == 0xFF)
bad460 ииииииif (--(key[2]) == 0xFF)
57a964 ииииииии--key[3];
c8815b ииfor (i = 0; i < 56; i++)
b6f7c3 ииииbinKey[i] = (key[i/8] >> (i&7)) & 1;
e3b642 ииfor (i = 7; i >= 0; i--) {
221e9a ииииj = binKey[i*7]*2 + binKey[i*7+1]*4 + binKey[i*7+2]*8 + binKey[i*7+3]*16 +
--3b12 000f2b672408002000c Page 8 of search.c
a35717 ииииииииbinKey[i*7+4]*32 + binKey[i*7+5]*64 + binKey[i*7+6]*128;
9b3764 ииииsprintf(buf+14-2*i, "%02X", j);
5bdf1c ии}
a9af5a
5076d5 ииif (QUIET)
19c6bc ииииprintf("Halt in %02X.%02X.%02X, K=%s P=", cp->board, cp->chip, unit, buf);
be3a1e ииelse {
80b718 ииииprintf("BOARD 0x%02X, CHIP 0x%02X, UNIT 0x%02X HALTED!\n иииK56 = ",
99c03b ииииииииииииcp->board, cp->chip, unit);
889ac7 ииииfor (i = 6; i >= 0; i--) printf("%02X", key[i]);

9d52d1 ииииprintf("\n иииK64 = %s\n", buf);
8adf1c ии}
5ecce4 ииif (FP_LOG) {
4757b8 ииииfprintf(FP_LOG, "Halt@ %02X.%02X.%02X, K=",
82c03b ииииииииииииcp->board, cp->chip, unit);
2a1890 ииииfor (i = 6; i >= 0; i--) fprintf(FP_LOG, "%02X", key[i]);
8ba909 ииииif (VERBOSE) fprintf(FP_LOG, ", K64=%s", buf);
ccdf1c ии}
31af5a
eedd3c ииgoodKey = CheckKey(binKey, ctx); иииииииииииииииииииии/* prints plaintexts */
efaf5a
7005cd ииif (QUIET) printf(goodKey ? " (OK!)\n" : " (BAD)\n");

352ace ииelse printf(" иии***** KEY IS %s *****\n", goodKey ? " OKAY " : "BAD");
7d1792 ииif (FP_LOG) fprintf(FP_LOG, goodKey ? " (=OK!)\n" : " (=BAD)\n");
24b77b ииfflush(stdout);
8384bd ииif (FP_LOG) fflush(FP_LOG);
35efe6 }
41af5a
2daf5a
d238e5 /*
0b1cdc и* иLet the user see what's going on.
f3495d и*/
6bfd4b int ServiceKeyboard(SEARCH_CTX *ctx) {
c31df9 ииint k, i, board, chip, reg, val;
08431e ииchar buffer[128];
e6af5a
57c536 ииwhile (kbhit()) {
d70480 ииииk = toupper(getch());
7d037e ииииif (k == '?') {
b83116 ииииииprintf("Keystroke options:\n иииESC=quit search\n");
2dbdd0 ииииииprintf(" иииR=read a chip\n иииSPACE=status\n иииP=pause\n");
c7e45d ииииииprintf(" иииS=set register\n");
d7aa86 ииииииprintf("Press a command letter, ENTER to continue\n");
fcbc76 ииииииwhile (!kbhit()) {}

045f6a ииииииcontinue;
4a6fe7 ииии}
0eb946 ииииif (k == 'P') {
a98ae3 ииииииfprintf(stderr, " и--- PAUSED ---\n(Press a command letter, ");
ff44cc ииииииfprintf(stderr, "ENTER to continue, or ? for help.)\n");
43bc76 ииииииwhile (!kbhit()) {}
8a5f6a ииииииcontinue;
926fe7 ииии}
a30d23 ииииif (k == 27) {
70cb2a ииииииfprintf(stderr, " и-- ESC PRESSED! HIT 'Y' TO CONFIRM HALT --\n");
8c5d92 ииииииif (toupper(getch()) == 'Y') {

14ea98 ииииииииfprintf(stderr, "Halting...\n");

f28ef9 ииииииииreturn (-1);
9e42cc ииииии}
5e4ac1 ииииииfprintf(stderr, " ии(Not halting.)\n");
c85f6a ииииииcontinue;
d46fe7 ииии}
517c47 ииииif (k == ' ') {
0a5669 ииииииfprintf(stderr, "There are %ld search units running\n", ctx->totalUnits);
97531b ииииииfprintf(stderr, "Of %ld blocks: %ld done, %ld unstarted, %ld pending\n",
a34f0b ииииииииииии1L<<24, ctx->totalFinishedKeyBlocks, ctx->totalUnstartedKeyBlocks,
99b056 ииииииииииииctx->totalPendingKeyBlocks);
cce226 ииииииfprintf(stderr, "The next key block to start is 0x%06lX.\n",
c1657e ииииииииииииииctx->nextUnstartedKeyBlock);
afb365 ииииииfprintf(stderr, "Press a command letter or ENTER to continue\n");
5cbc76 ииииииwhile (!kbhit()) {}
256fe7 ииии}
f2b110 ииииif (k == 'R') {
--ec05 0009a3bfee08002000c Page 9 of search.c
e2fbb8 ииииииfprintf(stderr, "Enter board and chip (in hex): ");
e27c75 ииииииfgets(buffer, 127, stdin);
91f579 ииииииboard = chip = -1;
1aea10 ииииииsscanf(buffer, "%x %x", &board, &chip);
20e47c ииииииif (board < 0 || board > 255 || chip < 0 || chip > 255) {

c9e3e0 ииииииииfprintf(stderr, "Bad board (0x%02X) or chip (0x%02X)\n", board, chip);
311474 ииииииииcontinue;
6042cc ииииии}
707553 ииииииfor (i = 0; i < 256; i++) {
f98149 ииииииииif ((i & 15) == 0)
85d1e0 ииииииииииprintf("\n0x%02X 0x%02X 0x%02X:", board, chip, i);
28fc62 ииииииииprintf(" %02X", GetRegister(board, chip, i));
0c42cc ииииии}
d046a0 ииииииprintf("\n");
41b365 ииииииfprintf(stderr, "Press a command letter or ENTER to continue\n");
7dbc76 ииииииwhile (!kbhit()) {}
555f6a ииииииcontinue;
406fe7 ииии}
2eb53b ииииif (k == 'S') {


a57f96 ииииииfprintf(stderr, "Enter board chip reg value (all hex): ");
af7c75 ииииииfgets(buffer, 127, stdin);
d40ef2 ииииииboard = chip = reg = val = -1;
629b24 ииииииsscanf(buffer, "%x %x %x %x", &board, &chip, &reg, &val);

cffcea ииииииif (board >= 0 && chip >= 0 && reg >= 0 && val >= 0) {
55a015 ииииииииfprintf(stderr, "Writing 0x%02X to 0x%02X.0x%02X reg 0x%02X\n",
287597 ииииииииииииval, board, chip, reg);

0391e8 ииииииииSetRegister(board, chip, reg, val);
b142cc ииииии}

a69b63 ииииииfprintf(stderr, "Press a command letter or ENTER to continue.\n");
7cbc76 ииииииwhile (!kbhit()) {}
b05f6a ииииииcontinue;
dc6fe7 ииии}
c5df1c ии}
77c86a ииreturn (0);
fdefe6 }
02af5a
85af5a
a638e5 /*
554279 и* иIf needed, this function can be used to decide whether keys are
f53655 и* иииииactually good or not to reject false positives.
c4ca0f и* иReturns 1 if the key is not bad, zero if it is wrong.
80495d и*/

c318aa int CheckKey(unsigned char key[56], SEARCH_CTX *ctx) {

bb169a ииbool ctxt[64],ptxt0[64],ptxt1[64];
45ac6d ииunsigned char p0[8],p1[8];
937d24 ииint i,c;
7faf5a
5148b0 ии/* Compute the plaintext and try to print it to the screen */
085c33 ииfor (i = 0; i < 64; i++)
8e67cf ииииctxt[i] = (ctx->ciphertext0[i/8] >> (i&7)) & 1;

fd0c6e ииDecryptDES((bool*)key, ptxt0, ctxt, 0);
1b8715 ииfor (i = 0; i < 8; i++) {
5e24a8 ииииp0[i] = (unsigned char)(ptxt0[i*8+0]+ptxt0[i*8+1]*2+ptxt0[i*8+2]*4+
a028a1 иииииииииииptxt0[i*8+3]*8+ptxt0[i*8+4]*16+ptxt0[i*8+5]*32+ptxt0[i*8+6]*64+
a14997 иииииииииииptxt0[i*8+7]*128);
9ddf1c ии}
871f76 ииfor (i = 0; i < 8; i++)
161698 ииииp0[i] ^= ctx->plaintextXorMask[i];
c2eed0 ииif (!QUIET) {
1449b2 ииииprintf(" иииPlaintext0 =");
216b40 ииииfor (i = 7; i>=0; i--) printf(" %02X", p0[i]);

2c7bdf ииииprintf(" ии(\"");
dd9984 ииииfor (i = 7; i>=0; i--)
ce1bc2 ииииииprintf("%c", (p0[i] < 32) ? '?' : p0[i]);
5bbc64 ииииprintf("\")\n");
5bdf1c ии}
9ba0a6 ииif (QUIET) for (i = 7; i>=0; i--) printf("%02X", p0[i]);
e4036d ииif (FP_LOG) fprintf(FP_LOG, ", ptxt=");
c74e9a ииif (FP_LOG) for (i = 7; i>=0; i--) fprintf(FP_LOG, "%02X", p0[i]);
60af5a
9a5c33 ииfor (i = 0; i < 64; i++)
9ace92 ииииctxt[i] = (ctx->ciphertext1[i/8] >> (i&7)) & 1;
--fcb9 0011107d9008002000c Page 10 of search.c
3509c3 ииDecryptDES((bool*)key, ptxt1, ctxt, 0);
b18715 ииfor (i = 0; i < 8; i++) {
c72b26 ииииp1[i] = (unsigned char)(ptxt1[i*8+0]+ptxt1[i*8+1]*2+ptxt1[i*8+2]*4+
9df932 иииииииииииptxt1[i*8+3]*8+ptxt1[i*8+4]*16+ptxt1[i*8+5]*32+ptxt1[i*8+6]*64+
c301bd иииииииииииptxt1[i*8+7]*128);
f7df1c ии}
839a9d ииif (ctx->searchInfo & 1) { ииииииииииииииии/* if CBC mode, XOR w/ 1st ctxt */
7e0371 ииииfor (i = 0; i < 8; i++)
d78c4c ииииииp1[i] ^= ctx->ciphertext0[i];

eedf1c ии}
4bef0f ииif (!QUIET) printf(" иииPlaintext1 =");
b2991b ииif (QUIET) printf("/");
e2a99a ииif (FP_LOG) fprintf(FP_LOG, "/");
615a96 ииif (!QUIET) for (i = 7; i>=0; i--) printf(" %02X", p1[i]);

4c3f73 ииif (QUIET) for (i = 7; i>=0; i--) printf("%02X", p1[i]);
aad14f ииif (FP_LOG) for (i = 7; i>=0; i--) fprintf(FP_LOG, "%02X", p1[i]);
54eed0 ииif (!QUIET) {

867bdf ииииprintf(" ии(\"");
659984 ииииfor (i = 7; i>=0; i--)
18d65f ииииииprintf("%c", (p1[i] < 32) ? '?' : p1[i]);
8bbc64 ииииprintf("\")\n");
1adf1c ии}
edaf5a
70b5e8 ии/* Reject key if doesn't contain good characters */
14ca29 ииfor(i = 0; i < 8;i++) {
900762 ииииif (((ctx->plaintextByteMask) >> i) & 1)
fb5f6a ииииииcontinue;

a14d40 ииииc = p0[i];
2e24c1 ииииif (((ctx->plaintextVector[c/8] >> (c & 7)) & 1) == 0)
08df24 ииииииreturn (0);
2f496b ииииc = p1[i];
2624c1 ииииif (((ctx->plaintextVector[c/8] >> (c & 7)) & 1) == 0)
d9df24 ииииииreturn (0);
29df1c ии}
eaaf5a
9e6000 ии/*
66bb06 иии* иINSERT ADDITIONAL CODE HERE TO REJECT FALSE POSITIVES
8ef9a6 иии*/
82d4d1 ииreturn (1);
06efe6 }
11af5a
--2752 00185ee2d9a8002000d Page 1 of search.h
8d2d03 /*****************************************************************************
58bbd7 и* search.h иииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииии*
b0c275 и* ииииииииииииииииииииииииHeader file for search.c иииииииииииииииииииииииии*
a129eb и* ииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииии*
7d09fc и* иииWritten 1998 by Cryptography Research (http://www.cryptography.com) иии*
b28aaf и* ииииииand Paul Kocher for the Electronic Frontier Foundation (EFF). ииииии*
e4caeb и* ииииииPlaced in the public domain by Cryptography Research and EFF. ииииии*
584992 и* иTHIS IS UNSUPPORTED FREE SOFTWARE. USE AND DISTRIBUTE AT YOUR OWN RISK. и*
4529eb и* ииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииии*
a4c755 и* иIMPORTANT: U.S. LAW MAY REGULATE THE USE AND/OR EXPORT OF THIS PROGRAM. и*
a529eb и* ииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииии*
cd489b и*****************************************************************************
7b29eb и* ииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииии*
aa6eef и* ииREVISION HISTORY: ииииииииииииииииииииииииииииииииииииииииииииииииииииии*
0d29eb и* ииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииии*
6e28d9 и* ииVersion 1.0: иInitial release by Cryptography Research to EFF. иииииииии*
e829eb и* ииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииии*
fbd8c3 и*****************************************************************************/
24af5a
01915a #ifndef __SEARCH_H
835ec3 #define __SEARCH_H
32af5a
42f0f7 typedef struct {
28e10b ии/* PARAMETERS DEFINING THE SEARCH (THESE GO IN THE SEARCH CONTEXT FILE) */
613b99 ииunsigned char plaintextVector[256/8];
9b6f32 ииunsigned char plaintextXorMask[8];
69ed17 ииunsigned char ciphertext0[8];
15e93c ииunsigned char ciphertext1[8];
c6b1b4 ииunsigned char plaintextByteMask;
360356 ииunsigned char searchInfo;
83af5a
354b87 ии/* PARAMETERS ABOUT THE SEARCH PROCESS */
d8cecc ииlong totalUnits; ииииииииииииииииииииииииииииииииииии/* total search units */
2dd51a ииlong nextUnstartedKeyBlock; иииииииииииииииииииииииииии/* top 24 bits only */
9a86cd ииlong totalFinishedKeyBlocks; ииииииииииии/* number of completed key blocks */
e769ab ииlong totalUnstartedKeyBlocks; иииииииииии/* number of blocks left to start */
ae947a ииlong totalPendingKeyBlocks; иииииииииииииииииии/* number of blocks running */
9a5317 } SEARCH_CTX;
f5af5a
8b7454 #endif
85af5a
